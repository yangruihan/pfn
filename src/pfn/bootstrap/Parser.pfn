-- Pfn Bootstrap: Parser
-- Syntax analyzer for Pfn language

module Bootstrap.Parser

import Bootstrap.Token (Token, TokenType, Span, TokenValue(..))
import Bootstrap.AST (..)

-- ============ Error Handling ============

type ParseError = {
  message: String,
  token: Token
}

def parseError(message: String, token: Token) : ParseError =
  { message: message, token: token }

def errorToString(err: ParseError) : String =
  err.message ++ " at " ++ spanToString(err.token.span)

def spanToString(span: Span) : String =
  "line " ++ toString(span.line) ++ ", column " ++ toString(span.column)

-- ============ Parser State ============

type ParserState = {
  tokens: List Token,
  pos: Int
}

def initParser(tokens: List Token) : ParserState =
  { tokens: tokens, pos: 0 }

-- ============ Precedence Table ============

-- Operator precedence (lower number = lower precedence)
def precedence : Dict TokenType Int =
  Dict.fromList [
    (DOUBLE_PIPE, 1),    -- ||
    (DOUBLE_AMP, 2),     -- &&
    (EQ, 3),             -- ==
    (NEQ, 3),            -- !=
    (LT, 3),             -- <
    (LE, 3),             -- <=
    (GT, 3),             -- >
    (GE, 3),             -- >=
    (DOUBLE_COLON, 4),   -- ::
    (DOUBLE_PLUS, 5),    -- ++
    (PLUS, 6),           -- +
    (MINUS, 6),          -- -
    (STAR, 7),           -- *
    (SLASH, 7),          -- /
    (PERCENT, 7),        -- %
    (FAT_ARROW, 8)       -- =>
  ]

def getPrecedence(tt: TokenType) : Int =
  match Dict.lookup(tt, precedence) with
    Just(p) -> p
    Nothing -> 0

-- ============ Token Access Helpers ============

-- Get current token
def current(state: ParserState) : Token =
  match List.getAt(state.pos, state.tokens) with
    Just(t) -> t
    Nothing -> 
      -- Return last token (EOF) if out of bounds
      match List.last(state.tokens) with
        Just(t) -> t
        Nothing -> { tokenType: EOF, value: NoValue, span: { start: 0, end: 0, line: 1, column: 1 } }

-- Peek at next token
def peek(state: ParserState) : Token =
  match List.getAt(state.pos + 1, state.tokens) with
    Just(t) -> t
    Nothing -> current(state)

-- Check if current token matches any of the given types
def check(state: ParserState, types: List TokenType) : Bool =
  List.member(current(state).tokenType, types)

-- Try to match and consume a token of the given types
def matchToken(state: ParserState, types: List TokenType) : (Maybe Token, ParserState) =
  if check(state, types) then
    (Just(current(state)), { state with pos = state.pos + 1 })
  else
    (Nothing, state)

-- Expect a token of the given type, raise error if not found
def expect(state: ParserState, tt: TokenType, message: String) : Result ParseError (Token, ParserState) =
  if check(state, [tt]) then
    let (mtok, newState) = matchToken(state, [tt])
    in match mtok with
      Just(t) -> Ok((t, newState))
      Nothing -> Err(parseError(message, current(state)))
  else
    Err(parseError(message, current(state)))

-- Advance position by one
def advance(state: ParserState) : ParserState =
  { state with pos = state.pos + 1 }

-- ============ Token Value Extraction ============

def getTokenString(token: Token) : String =
  match token.value with
    StringValue(s) -> s
    _ -> ""

def getTokenInt(token: Token) : Int =
  match token.value with
    IntValue(i) -> i
    _ -> 0

def getTokenFloat(token: Token) : Float =
  match token.value with
    FloatValue(f) -> f
    _ -> 0.0

def getTokenChar(token: Token) : Char =
  match token.value with
    CharValue(c) -> c
    _ -> '\0'

-- ============ Main Parse Function ============

-- Parse a module from tokens
def parse(tokens: List Token) : Result ParseError Module =
  parseModule(initParser(tokens))

-- Parse module declarations
def parseModule(state: ParserState) : Result ParseError Module =
  parseDeclarations(state, [])

-- Collect all declarations
def parseDeclarations(state: ParserState, decls: List Decl) : Result ParseError Module =
  if check(state, [EOF]) then
    Ok({ name: Nothing, declarations: List.reverse(decls) })
  else
    match parseDeclaration(state) with
      Ok((decl, newState)) -> parseDeclarations(newState, [decl] ++ decls)
      Err(e) -> Err(e)

-- ============ Declaration Parsing ============

-- Parse a single declaration
def parseDeclaration(state: ParserState) : Result ParseError (Decl, ParserState) =
  let (mDef, s1) = matchToken(state, [KW_DEF])
  in match mDef with
    Just(_) -> parseDef(s1, False, Nothing)
    Nothing ->
      let (mType, s2) = matchToken(state, [KW_TYPE])
      in match mType with
        Just(_) -> parseTypeDecl(s2)
        Nothing ->
          let (mGadt, s3) = matchToken(state, [KW_GADT])
          in match mGadt with
            Just(_) -> parseGadtDecl(s3)
            Nothing ->
              let (mImport, s4) = matchToken(state, [KW_IMPORT])
              in match mImport with
                Just(_) -> parseImportDecl(s4)
                Nothing ->
                  let (mInterface, s5) = matchToken(state, [KW_INTERFACE])
                  in match mInterface with
                    Just(_) -> parseInterfaceDecl(s5)
                    Nothing ->
                      let (mImpl, s6) = matchToken(state, [KW_IMPL])
                      in match mImpl with
                        Just(_) -> parseImplDecl(s6)
                        Nothing ->
                          let (mEffect, s7) = matchToken(state, [KW_EFFECT])
                          in match mEffect with
                            Just(_) -> parseEffectDecl(s7)
                            Nothing ->
                              let (mAt, s8) = matchToken(state, [AT])
                              in match mAt with
                                Just(_) -> parseDecorator(s8)
                                Nothing -> Err(parseError("Unexpected token: " ++ tokenTypeName(current(state).tokenType), current(state)))

-- Parse @py.export decorator
def parseDecorator(state: ParserState) : Result ParseError (Decl, ParserState) =
  if check(state, [IDENT]) && getTokenString(current(state)) == "py" then
    let s1 = advance(state)
    in if check(s1, [DOT]) then
      let s2 = advance(s1)
      in if check(s2, [IDENT]) && getTokenString(current(s2)) == "export" then
        let s3 = advance(s2)
        in let (mLParen, s4) = matchToken(s3, [LPAREN])
        in match mLParen with
          Just(_) ->
            match expect(s4, STRING, "Expected export name") with
              Ok((nameTok, s5)) ->
                match expect(s5, RPAREN, "Expected ')'") with
                  Ok((_, s6)) ->
                    match expect(s6, KW_DEF, "Expected 'def' after @py.export") with
                      Ok((_, s7)) ->
                        let exportName = getTokenString(nameTok)
                        in parseDef(s7, True, Just(exportName))
                      Err(e) -> Err(e)
                  Err(e) -> Err(e)
              Err(e) -> Err(e)
          Nothing ->
            match expect(s3, KW_DEF, "Expected 'def' after @py.export") with
              Ok((_, s4)) -> parseDef(s4, True, Nothing)
              Err(e) -> Err(e)
      else
        Err(parseError("Expected 'export' after '@py.'", current(s2)))
    else
      Err(parseError("Expected '.' after '@py'", current(s1)))
  else
    Err(parseError("Expected 'py' after '@'", current(state)))

-- Parse function definition
def parseDef(state: ParserState, isExported: Bool, exportName: Maybe String) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected function name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match parseParams(s1) with
        Ok((params, s2)) ->
          match parseReturnType(s2) with
            Ok((retType, s3)) ->
              match expect(s3, EQUALS, "Expected '=' after function signature") with
                Ok((_, s4)) ->
                  match parseExpr(s4) with
                    Ok((body, s5)) ->
                      Ok((DefDecl({
                        name: name,
                        params: params,
                        body: body,
                        returnType: retType,
                        isExported: isExported,
                        exportName: exportName
                      }), s5))
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse function parameters
def parseParams(state: ParserState) : Result ParseError (List Param, ParserState) =
  let (mLParen, s1) = matchToken(state, [LPAREN])
  in match mLParen with
    Just(_) ->
      if check(s1, [RPAREN]) then
        Ok(([], advance(s1)))
      else
        parseParamList(s1, [])
    Nothing -> Ok(([], state))

-- Parse parameter list inside parentheses
def parseParamList(state: ParserState, params: List Param) : Result ParseError (List Param, ParserState) =
  match parseParam(state) with
    Ok((param, s1)) ->
      let (mComma, s2) = matchToken(s1, [COMMA])
      in match mComma with
        Just(_) -> parseParamList(s2, params ++ [param])
        Nothing ->
          match expect(s1, RPAREN, "Expected ')' after parameters") with
            Ok((_, s3)) -> Ok((params ++ [param], s3))
            Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse single parameter
def parseParam(state: ParserState) : Result ParseError (Param, ParserState) =
  match expect(state, IDENT, "Expected parameter name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in let (mColon, s2) = matchToken(s1, [COLON])
      in match mColon with
        Just(_) ->
          match parseTypeRef(s2) with
            Ok((typeRef, s3)) -> Ok(({ name: name, typeAnnotation: Just(typeRef) }, s3))
            Err(e) -> Err(e)
        Nothing -> Ok(({ name: name, typeAnnotation: Nothing }, s1))
    Err(e) -> Err(e)

-- Parse optional return type
def parseReturnType(state: ParserState) : Result ParseError (Maybe TypeRef, ParserState) =
  let (mArrow, s1) = matchToken(state, [ARROW])
  in match mArrow with
    Just(_) ->
      match parseTypeRef(s1) with
        Ok((typeRef, s2)) -> Ok((Just(typeRef), s2))
        Err(e) -> Err(e)
    Nothing -> Ok((Nothing, state))

-- ============ Type Declaration Parsing ============

-- Parse type declaration
def parseTypeDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected type name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match parseTypeParams(s1) with
        Ok((params, s2)) ->
          let (mEquals, s3) = matchToken(s2, [EQUALS])
          in match mEquals with
            Just(_) ->
              match parseTypeRef(s3) with
                Ok((typeRef, s4)) ->
                  -- Check if it's a record type
                  match typeRef with
                    RecordTypeRef(data) ->
                      Ok((TypeDecl({
                        name: name,
                        params: params,
                        constructors: [],
                        isRecord: True,
                        recordFields: data.fields,
                        isGadt: False
                      }), s4))
                    _ ->
                      -- Parse constructors
                      match parseConstructors(s3, []) with
                        Ok((ctors, s5)) ->
                          Ok((TypeDecl({
                            name: name,
                            params: params,
                            constructors: ctors,
                            isRecord: False,
                            recordFields: [],
                            isGadt: False
                          }), s5))
                        Err(e) -> Err(e)
                Err(e) -> Err(e)
            Nothing ->
              match parseConstructors(s2, []) with
                Ok((ctors, s3)) ->
                  Ok((TypeDecl({
                    name: name,
                    params: params,
                    constructors: ctors,
                    isRecord: False,
                    recordFields: [],
                    isGadt: False
                  }), s3))
                Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse type parameters
def parseTypeParams(state: ParserState) : Result ParseError (List String, ParserState) =
  parseTypeParamsLoop(state, [])

def parseTypeParamsLoop(state: ParserState, params: List String) : Result ParseError (List String, ParserState) =
  if check(state, [IDENT]) then
    let peekTok = peek(state)
    in if List.member(peekTok.tokenType, [EQUALS, PIPE, EOF]) then
      let name = getTokenString(current(state))
      in parseTypeParamsLoop(advance(state), params ++ [name])
    else
      Ok((params, state))
  else
    Ok((params, state))

-- Parse constructors
def parseConstructors(state: ParserState, ctors: List Constructor) : Result ParseError (List Constructor, ParserState) =
  let (mPipe, s1) = matchToken(state, [PIPE])
  in match mPipe with
    Just(_) ->
      match expect(s1, IDENT, "Expected constructor name") with
        Ok((nameTok, s2)) ->
          let name = getTokenString(nameTok)
          in match parseConstructorFields(s2, []) with
            Ok((fields, s3)) ->
              parseConstructors(s3, ctors ++ [{ name: name, fields: fields }])
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Nothing -> Ok((ctors, state))

-- Parse constructor fields
def parseConstructorFields(state: ParserState, fields: List TypeRef) : Result ParseError (List TypeRef, ParserState) =
  if check(state, [IDENT]) && not(check(state, [PIPE, EOF])) then
    match parseTypeAtom(state) with
      Ok((typeRef, s1)) -> parseConstructorFields(s1, fields ++ [typeRef])
      Err(e) -> Err(e)
  else
    Ok((fields, state))

-- Parse GADT declaration
def parseGadtDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected type name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match parseTypeParams(s1) with
        Ok((params, s2)) ->
          match expect(s2, KW_WHERE, "Expected 'where'") with
            Ok((_, s3)) ->
              match expect(s3, LBRACE, "Expected '{'") with
                Ok((_, s4)) ->
                  match parseGadtConstructors(s4, []) with
                    Ok((ctors, s5)) ->
                      match expect(s5, RBRACE, "Expected '}'") with
                        Ok((_, s6)) ->
                          Ok((TypeDecl({
                            name: name,
                            params: params,
                            constructors: ctors,
                            isRecord: False,
                            recordFields: [],
                            isGadt: True
                          }), s6))
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse GADT constructors
def parseGadtConstructors(state: ParserState, ctors: List Constructor) : Result ParseError (List Constructor, ParserState) =
  if check(state, [RBRACE]) then
    Ok((ctors, state))
  else
    match expect(state, IDENT, "Expected constructor name") with
      Ok((nameTok, s1)) ->
        let name = getTokenString(nameTok)
        in match parseGadtFields(s1, []) with
          Ok((fields, s2)) ->
            let (mComma, s3) = matchToken(s2, [COMMA])
            in parseGadtConstructors(s3, ctors ++ [{ name: name, fields: fields }])
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- Parse GADT fields
def parseGadtFields(state: ParserState, fields: List TypeRef) : Result ParseError (List TypeRef, ParserState) =
  if check(state, [IDENT]) then
    match parseTypeRef(state) with
      Ok((typeRef, s1)) -> parseGadtFields(s1, fields ++ [typeRef])
      Err(e) -> Err(e)
  else
    Ok((fields, state))

-- ============ Import Declaration Parsing ============

def parseImportDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  let isPython = check(state, [IDENT]) && getTokenString(current(state)) == "python"
  in let s1 = if isPython then advance(state) else state
  in match expect(s1, IDENT, "Expected module name") with
    Ok((firstPart, s2)) ->
      let firstPartName = getTokenString(firstPart)
      in match parseModulePath(s2, [firstPartName]) with
        Ok((parts, s3)) ->
          let moduleName = String.join(".", parts)
          in let (mAs, s4) = matchToken(s3, [KW_AS])
          in match mAs with
            Just(_) ->
              match expect(s4, IDENT, "Expected alias") with
                Ok((aliasTok, s5)) ->
                  Ok((ImportDecl({
                    module: moduleName,
                    alias: Just(getTokenString(aliasTok)),
                    exposing: Nothing,
                    isPython: isPython
                  }), s5))
                Err(e) -> Err(e)
            Nothing ->
              Ok((ImportDecl({
                module: moduleName,
                alias: Nothing,
                exposing: Nothing,
                isPython: isPython
              }), s4))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse module path (a.b.c)
def parseModulePath(state: ParserState, parts: List String) : Result ParseError (List String, ParserState) =
  let (mDot, s1) = matchToken(state, [DOT])
  in match mDot with
    Just(_) ->
      match expect(s1, IDENT, "Expected module part") with
        Ok((partTok, s2)) ->
          parseModulePath(s2, parts ++ [getTokenString(partTok)])
        Err(e) -> Err(e)
    Nothing -> Ok((parts, state))

-- ============ Interface Declaration Parsing ============

def parseInterfaceDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected interface name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match parseTypeParams(s1) with
        Ok((params, s2)) ->
          match expect(s2, KW_WHERE, "Expected 'where'") with
            Ok((_, s3)) ->
              match expect(s3, LBRACE, "Expected '{'") with
                Ok((_, s4)) ->
                  match parseInterfaceMethods(s4, []) with
                    Ok((methods, s5)) ->
                      match expect(s5, RBRACE, "Expected '}'") with
                        Ok((_, s6)) ->
                          Ok((InterfaceDecl({
                            name: name,
                            params: params,
                            methods: methods,
                            superclasses: []
                          }), s6))
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse interface methods
def parseInterfaceMethods(state: ParserState, methods: List InterfaceMethod) : Result ParseError (List InterfaceMethod, ParserState) =
  if check(state, [RBRACE]) then
    Ok((methods, state))
  else
    match expect(state, IDENT, "Expected method name") with
      Ok((nameTok, s1)) ->
        match expect(s1, COLON, "Expected ':'") with
          Ok((_, s2)) ->
            match parseTypeRef(s2) with
              Ok((typeRef, s3)) ->
                let (mComma, s4) = matchToken(s3, [COMMA])
                in parseInterfaceMethods(s4, methods ++ [{ name: getTokenString(nameTok), type: typeRef }])
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- ============ Impl Declaration Parsing ============

def parseImplDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected class name") with
    Ok((classNameTok, s1)) ->
      let className = getTokenString(classNameTok)
      in match parseTypeRef(s1) with
        Ok((typeRef, s2)) ->
          match expect(s2, KW_WHERE, "Expected 'where'") with
            Ok((_, s3)) ->
              match expect(s3, LBRACE, "Expected '{'") with
                Ok((_, s4)) ->
                  match parseImplMethods(s4, []) with
                    Ok((methods, s5)) ->
                      match expect(s5, RBRACE, "Expected '}'") with
                        Ok((_, s6)) ->
                          Ok((ImplDecl({
                            className: className,
                            typeRef: typeRef,
                            methods: methods
                          }), s6))
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse impl methods
def parseImplMethods(state: ParserState, methods: List ImplMethod) : Result ParseError (List ImplMethod, ParserState) =
  if check(state, [RBRACE]) then
    Ok((methods, state))
  else
    match expect(state, IDENT, "Expected method name") with
      Ok((nameTok, s1)) ->
        match parseParams(s1) with
          Ok((params, s2)) ->
            match expect(s2, EQUALS, "Expected '='") with
              Ok((_, s3)) ->
                match parseExpr(s3) with
                  Ok((body, s4)) ->
                    let (mComma, s5) = matchToken(s4, [COMMA])
                    in parseImplMethods(s5, methods ++ [{ name: getTokenString(nameTok), params: params, body: body }])
                  Err(e) -> Err(e)
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- ============ Effect Declaration Parsing ============

def parseEffectDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected effect name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match expect(s1, LBRACE, "Expected '{'") with
        Ok((_, s2)) ->
          match parseEffectOps(s2, []) with
            Ok((ops, s3)) ->
              match expect(s3, RBRACE, "Expected '}'") with
                Ok((_, s4)) ->
                  Ok((EffectDecl({
                    name: name,
                    operations: ops
                  }), s4))
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse effect operations
def parseEffectOps(state: ParserState, ops: List EffectOp) : Result ParseError (List EffectOp, ParserState) =
  if check(state, [RBRACE]) then
    Ok((ops, state))
  else
    match expect(state, IDENT, "Expected operation name") with
      Ok((nameTok, s1)) ->
        match expect(s1, COLON, "Expected ':'") with
          Ok((_, s2)) ->
            match parseTypeRef(s2) with
              Ok((typeRef, s3)) ->
                let (mComma, s4) = matchToken(s3, [COMMA])
                in parseEffectOps(s4, ops ++ [{ name: getTokenString(nameTok), type: typeRef }])
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- ============ Type Reference Parsing ============

-- Parse type reference (entry point)
def parseTypeRef(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  parseTypeArrow(state)

-- Parse arrow type (function type)
def parseTypeArrow(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  match parseTypeApp(state) with
    Ok((left, s1)) ->
      let (mArrow, s2) = matchToken(s1, [ARROW])
      in match mArrow with
        Just(_) ->
          match parseTypeArrow(s2) with
            Ok((right, s3)) -> Ok((FunTypeRef({ param: left, result: right }), s3))
            Err(e) -> Err(e)
        Nothing -> Ok((left, s1))
    Err(e) -> Err(e)

-- Parse type application
def parseTypeApp(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  match parseTypeAtom(state) with
    Ok((base, s1)) ->
      match parseTypeArgs(s1, []) with
        Ok((args, s2)) ->
          if List.isEmpty(args) then
            Ok((base, s2))
          else
            match base with
              SimpleTypeRef(data) ->
                Ok((SimpleTypeRef({ name: data.name, args: args }), s2))
              _ -> Ok((base, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse type arguments
def parseTypeArgs(state: ParserState, args: List TypeRef) : Result ParseError (List TypeRef, ParserState) =
  if check(state, [IDENT]) then
    match parseTypeAtom(state) with
      Ok((typeRef, s1)) -> parseTypeArgs(s1, args ++ [typeRef])
      Err(e) -> Err(e)
  else
    Ok((args, state))

-- Parse atomic type
def parseTypeAtom(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  let (mLParen, s1) = matchToken(state, [LPAREN])
  in match mLParen with
    Just(_) ->
      if check(s1, [RPAREN]) then
        Ok((TupleTypeRef({ elements: [] }), advance(s1)))
      else
        match parseTypeRef(s1) with
          Ok((inner, s2)) ->
            let (mComma, s3) = matchToken(s2, [COMMA])
            in match mComma with
              Just(_) ->
                match parseTupleTypes(s3, [inner]) with
                  Ok((elements, s4)) ->
                    match expect(s4, RPAREN, "Expected ')' after tuple type") with
                      Ok((_, s5)) -> Ok((TupleTypeRef({ elements: elements }), s5))
                      Err(e) -> Err(e)
                  Err(e) -> Err(e)
              Nothing ->
                match expect(s2, RPAREN, "Expected ')'") with
                  Ok((_, s3)) -> Ok((inner, s3))
                  Err(e) -> Err(e)
          Err(e) -> Err(e)
    Nothing ->
      let (mLBracket, s2) = matchToken(state, [LBRACKET])
      in match mLBracket with
        Just(_) ->
          match parseTypeRef(s2) with
            Ok((elemType, s3)) ->
              match expect(s3, RBRACKET, "Expected ']' after list type") with
                Ok((_, s4)) -> Ok((SimpleTypeRef({ name: "List", args: [elemType] }), s4))
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Nothing ->
          let (mLBrace, s3) = matchToken(state, [LBRACE])
          in match mLBrace with
            Just(_) -> parseRecordType(s3)
            Nothing ->
              match expect(state, IDENT, "Expected type name") with
                Ok((nameTok, s4)) ->
                  Ok((SimpleTypeRef({ name: getTokenString(nameTok), args: [] }), s4))
                Err(e) -> Err(e)

-- Parse tuple types
def parseTupleTypes(state: ParserState, elements: List TypeRef) : Result ParseError (List TypeRef, ParserState) =
  if check(state, [RPAREN]) then
    Ok((elements, state))
  else
    match parseTypeRef(state) with
      Ok((typeRef, s1)) ->
        let (mComma, s2) = matchToken(s1, [COMMA])
        in parseTupleTypes(s2, elements ++ [typeRef])
      Err(e) -> Err(e)

-- Parse record type
def parseRecordType(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  if check(state, [RBRACE]) then
    match expect(state, RBRACE, "Expected '}' after record type") with
      Ok((_, s1)) -> Ok((RecordTypeRef({ fields: [] }), s1))
      Err(e) -> Err(e)
  else
    match parseRecordFields(state, []) with
      Ok((fields, s1)) ->
        match expect(s1, RBRACE, "Expected '}' after record type") with
          Ok((_, s2)) -> Ok((RecordTypeRef({ fields: fields }), s2))
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- Parse record fields
def parseRecordFields(state: ParserState, fields: List (String, TypeRef)) : Result ParseError (List (String, TypeRef), ParserState) =
  match expect(state, IDENT, "Expected field name") with
    Ok((nameTok, s1)) ->
      match expect(s1, COLON, "Expected ':' after field name") with
        Ok((_, s2)) ->
          match parseTypeRef(s2) with
            Ok((typeRef, s3)) ->
              let (mComma, s4) = matchToken(s3, [COMMA])
              in if check(s4, [RBRACE]) then
                Ok((fields ++ [(getTokenString(nameTok), typeRef)], s4))
              else
                parseRecordFields(s4, fields ++ [(getTokenString(nameTok), typeRef)])
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)
