-- Pfn Bootstrap: Parser
-- Syntax analyzer for Pfn language

module Bootstrap.Parser

import Bootstrap.Token (Token, TokenType, Span, TokenValue(..))
import Bootstrap.AST (..)

-- ============ Error Handling ============

type ParseError = {
  message: String,
  token: Token
}

def parseError(message: String, token: Token) : ParseError =
  { message: message, token: token }

def errorToString(err: ParseError) : String =
  err.message ++ " at " ++ spanToString(err.token.span)

def spanToString(span: Span) : String =
  "line " ++ toString(span.line) ++ ", column " ++ toString(span.column)

-- ============ Parser State ============

type ParserState = {
  tokens: List Token,
  pos: Int
}

def initParser(tokens: List Token) : ParserState =
  { tokens: tokens, pos: 0 }

-- ============ Precedence Table ============

-- Operator precedence (lower number = lower precedence)
def precedence : Dict TokenType Int =
  Dict.fromList [
    (DOUBLE_PIPE, 1),    -- ||
    (DOUBLE_AMP, 2),     -- &&
    (EQ, 3),             -- ==
    (NEQ, 3),            -- !=
    (LT, 3),             -- <
    (LE, 3),             -- <=
    (GT, 3),             -- >
    (GE, 3),             -- >=
    (DOUBLE_COLON, 4),   -- ::
    (DOUBLE_PLUS, 5),    -- ++
    (PLUS, 6),           -- +
    (MINUS, 6),          -- -
    (STAR, 7),           -- *
    (SLASH, 7),          -- /
    (PERCENT, 7),        -- %
    (FAT_ARROW, 8)       -- =>
  ]

def getPrecedence(tt: TokenType) : Int =
  match Dict.lookup(tt, precedence) with
    Just(p) -> p
    Nothing -> 0

-- ============ Token Access Helpers ============

-- Get current token
def current(state: ParserState) : Token =
  match List.getAt(state.pos, state.tokens) with
    Just(t) -> t
    Nothing -> 
      -- Return last token (EOF) if out of bounds
      match List.last(state.tokens) with
        Just(t) -> t
        Nothing -> { tokenType: EOF, value: NoValue, span: { start: 0, end: 0, line: 1, column: 1 } }

-- Peek at next token
def peek(state: ParserState) : Token =
  match List.getAt(state.pos + 1, state.tokens) with
    Just(t) -> t
    Nothing -> current(state)

-- Check if current token matches any of the given types
def check(state: ParserState, types: List TokenType) : Bool =
  List.member(current(state).tokenType, types)

-- Try to match and consume a token of the given types
def matchToken(state: ParserState, types: List TokenType) : (Maybe Token, ParserState) =
  if check(state, types) then
    (Just(current(state)), { state with pos = state.pos + 1 })
  else
    (Nothing, state)

-- Expect a token of the given type, raise error if not found
def expect(state: ParserState, tt: TokenType, message: String) : Result ParseError (Token, ParserState) =
  if check(state, [tt]) then
    let (mtok, newState) = matchToken(state, [tt])
    in match mtok with
      Just(t) -> Ok((t, newState))
      Nothing -> Err(parseError(message, current(state)))
  else
    Err(parseError(message, current(state)))

-- Advance position by one
def advance(state: ParserState) : ParserState =
  { state with pos = state.pos + 1 }

-- ============ Token Value Extraction ============

def getTokenString(token: Token) : String =
  match token.value with
    StringValue(s) -> s
    _ -> ""

def getTokenInt(token: Token) : Int =
  match token.value with
    IntValue(i) -> i
    _ -> 0

def getTokenFloat(token: Token) : Float =
  match token.value with
    FloatValue(f) -> f
    _ -> 0.0

def getTokenChar(token: Token) : Char =
  match token.value with
    CharValue(c) -> c
    _ -> '\0'

-- ============ Main Parse Function ============

-- Parse a module from tokens
def parse(tokens: List Token) : Result ParseError Module =
  parseModule(initParser(tokens))

-- Parse module declarations
def parseModule(state: ParserState) : Result ParseError Module =
  parseDeclarations(state, [])

-- Collect all declarations
def parseDeclarations(state: ParserState, decls: List Decl) : Result ParseError Module =
  if check(state, [EOF]) then
    Ok({ name: Nothing, declarations: List.reverse(decls) })
  else
    match parseDeclaration(state) with
      Ok((decl, newState)) -> parseDeclarations(newState, [decl] ++ decls)
      Err(e) -> Err(e)

-- ============ Declaration Parsing ============

-- Parse a single declaration
def parseDeclaration(state: ParserState) : Result ParseError (Decl, ParserState) =
  let (mDef, s1) = matchToken(state, [KW_DEF])
  in match mDef with
    Just(_) -> parseDef(s1, False, Nothing)
    Nothing ->
      let (mType, s2) = matchToken(state, [KW_TYPE])
      in match mType with
        Just(_) -> parseTypeDecl(s2)
        Nothing ->
          let (mGadt, s3) = matchToken(state, [KW_GADT])
          in match mGadt with
            Just(_) -> parseGadtDecl(s3)
            Nothing ->
              let (mImport, s4) = matchToken(state, [KW_IMPORT])
              in match mImport with
                Just(_) -> parseImportDecl(s4)
                Nothing ->
                  let (mInterface, s5) = matchToken(state, [KW_INTERFACE])
                  in match mInterface with
                    Just(_) -> parseInterfaceDecl(s5)
                    Nothing ->
                      let (mImpl, s6) = matchToken(state, [KW_IMPL])
                      in match mImpl with
                        Just(_) -> parseImplDecl(s6)
                        Nothing ->
                          let (mEffect, s7) = matchToken(state, [KW_EFFECT])
                          in match mEffect with
                            Just(_) -> parseEffectDecl(s7)
                            Nothing ->
                              let (mAt, s8) = matchToken(state, [AT])
                              in match mAt with
                                Just(_) -> parseDecorator(s8)
                                Nothing -> Err(parseError("Unexpected token: " ++ tokenTypeName(current(state).tokenType), current(state)))

-- Parse @py.export decorator
def parseDecorator(state: ParserState) : Result ParseError (Decl, ParserState) =
  if check(state, [IDENT]) && getTokenString(current(state)) == "py" then
    let s1 = advance(state)
    in if check(s1, [DOT]) then
      let s2 = advance(s1)
      in if check(s2, [IDENT]) && getTokenString(current(s2)) == "export" then
        let s3 = advance(s2)
        in let (mLParen, s4) = matchToken(s3, [LPAREN])
        in match mLParen with
          Just(_) ->
            match expect(s4, STRING, "Expected export name") with
              Ok((nameTok, s5)) ->
                match expect(s5, RPAREN, "Expected ')'") with
                  Ok((_, s6)) ->
                    match expect(s6, KW_DEF, "Expected 'def' after @py.export") with
                      Ok((_, s7)) ->
                        let exportName = getTokenString(nameTok)
                        in parseDef(s7, True, Just(exportName))
                      Err(e) -> Err(e)
                  Err(e) -> Err(e)
              Err(e) -> Err(e)
          Nothing ->
            match expect(s3, KW_DEF, "Expected 'def' after @py.export") with
              Ok((_, s4)) -> parseDef(s4, True, Nothing)
              Err(e) -> Err(e)
      else
        Err(parseError("Expected 'export' after '@py.'", current(s2)))
    else
      Err(parseError("Expected '.' after '@py'", current(s1)))
  else
    Err(parseError("Expected 'py' after '@'", current(state)))

-- Parse function definition
def parseDef(state: ParserState, isExported: Bool, exportName: Maybe String) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected function name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match parseParams(s1) with
        Ok((params, s2)) ->
          match parseReturnType(s2) with
            Ok((retType, s3)) ->
              match expect(s3, EQUALS, "Expected '=' after function signature") with
                Ok((_, s4)) ->
                  match parseExpr(s4) with
                    Ok((body, s5)) ->
                      Ok((DefDecl({
                        name: name,
                        params: params,
                        body: body,
                        returnType: retType,
                        isExported: isExported,
                        exportName: exportName
                      }), s5))
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse function parameters
def parseParams(state: ParserState) : Result ParseError (List Param, ParserState) =
  let (mLParen, s1) = matchToken(state, [LPAREN])
  in match mLParen with
    Just(_) ->
      if check(s1, [RPAREN]) then
        Ok(([], advance(s1)))
      else
        parseParamList(s1, [])
    Nothing -> Ok(([], state))

-- Parse parameter list inside parentheses
def parseParamList(state: ParserState, params: List Param) : Result ParseError (List Param, ParserState) =
  match parseParam(state) with
    Ok((param, s1)) ->
      let (mComma, s2) = matchToken(s1, [COMMA])
      in match mComma with
        Just(_) -> parseParamList(s2, params ++ [param])
        Nothing ->
          match expect(s1, RPAREN, "Expected ')' after parameters") with
            Ok((_, s3)) -> Ok((params ++ [param], s3))
            Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse single parameter
def parseParam(state: ParserState) : Result ParseError (Param, ParserState) =
  match expect(state, IDENT, "Expected parameter name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in let (mColon, s2) = matchToken(s1, [COLON])
      in match mColon with
        Just(_) ->
          match parseTypeRef(s2) with
            Ok((typeRef, s3)) -> Ok(({ name: name, typeAnnotation: Just(typeRef) }, s3))
            Err(e) -> Err(e)
        Nothing -> Ok(({ name: name, typeAnnotation: Nothing }, s1))
    Err(e) -> Err(e)

-- Parse optional return type
def parseReturnType(state: ParserState) : Result ParseError (Maybe TypeRef, ParserState) =
  let (mArrow, s1) = matchToken(state, [ARROW])
  in match mArrow with
    Just(_) ->
      match parseTypeRef(s1) with
        Ok((typeRef, s2)) -> Ok((Just(typeRef), s2))
        Err(e) -> Err(e)
    Nothing -> Ok((Nothing, state))

-- ============ Type Declaration Parsing ============

-- Parse type declaration
def parseTypeDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected type name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match parseTypeParams(s1) with
        Ok((params, s2)) ->
          let (mEquals, s3) = matchToken(s2, [EQUALS])
          in match mEquals with
            Just(_) ->
              match parseTypeRef(s3) with
                Ok((typeRef, s4)) ->
                  -- Check if it's a record type
                  match typeRef with
                    RecordTypeRef(data) ->
                      Ok((TypeDecl({
                        name: name,
                        params: params,
                        constructors: [],
                        isRecord: True,
                        recordFields: data.fields,
                        isGadt: False
                      }), s4))
                    _ ->
                      -- Parse constructors
                      match parseConstructors(s3, []) with
                        Ok((ctors, s5)) ->
                          Ok((TypeDecl({
                            name: name,
                            params: params,
                            constructors: ctors,
                            isRecord: False,
                            recordFields: [],
                            isGadt: False
                          }), s5))
                        Err(e) -> Err(e)
                Err(e) -> Err(e)
            Nothing ->
              match parseConstructors(s2, []) with
                Ok((ctors, s3)) ->
                  Ok((TypeDecl({
                    name: name,
                    params: params,
                    constructors: ctors,
                    isRecord: False,
                    recordFields: [],
                    isGadt: False
                  }), s3))
                Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse type parameters
def parseTypeParams(state: ParserState) : Result ParseError (List String, ParserState) =
  parseTypeParamsLoop(state, [])

def parseTypeParamsLoop(state: ParserState, params: List String) : Result ParseError (List String, ParserState) =
  if check(state, [IDENT]) then
    let peekTok = peek(state)
    in if List.member(peekTok.tokenType, [EQUALS, PIPE, EOF]) then
      let name = getTokenString(current(state))
      in parseTypeParamsLoop(advance(state), params ++ [name])
    else
      Ok((params, state))
  else
    Ok((params, state))

-- Parse constructors
def parseConstructors(state: ParserState, ctors: List Constructor) : Result ParseError (List Constructor, ParserState) =
  let (mPipe, s1) = matchToken(state, [PIPE])
  in match mPipe with
    Just(_) ->
      match expect(s1, IDENT, "Expected constructor name") with
        Ok((nameTok, s2)) ->
          let name = getTokenString(nameTok)
          in match parseConstructorFields(s2, []) with
            Ok((fields, s3)) ->
              parseConstructors(s3, ctors ++ [{ name: name, fields: fields }])
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Nothing -> Ok((ctors, state))

-- Parse constructor fields
def parseConstructorFields(state: ParserState, fields: List TypeRef) : Result ParseError (List TypeRef, ParserState) =
  if check(state, [IDENT]) && not(check(state, [PIPE, EOF])) then
    match parseTypeAtom(state) with
      Ok((typeRef, s1)) -> parseConstructorFields(s1, fields ++ [typeRef])
      Err(e) -> Err(e)
  else
    Ok((fields, state))

-- Parse GADT declaration
def parseGadtDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected type name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match parseTypeParams(s1) with
        Ok((params, s2)) ->
          match expect(s2, KW_WHERE, "Expected 'where'") with
            Ok((_, s3)) ->
              match expect(s3, LBRACE, "Expected '{'") with
                Ok((_, s4)) ->
                  match parseGadtConstructors(s4, []) with
                    Ok((ctors, s5)) ->
                      match expect(s5, RBRACE, "Expected '}'") with
                        Ok((_, s6)) ->
                          Ok((TypeDecl({
                            name: name,
                            params: params,
                            constructors: ctors,
                            isRecord: False,
                            recordFields: [],
                            isGadt: True
                          }), s6))
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse GADT constructors
def parseGadtConstructors(state: ParserState, ctors: List Constructor) : Result ParseError (List Constructor, ParserState) =
  if check(state, [RBRACE]) then
    Ok((ctors, state))
  else
    match expect(state, IDENT, "Expected constructor name") with
      Ok((nameTok, s1)) ->
        let name = getTokenString(nameTok)
        in match parseGadtFields(s1, []) with
          Ok((fields, s2)) ->
            let (mComma, s3) = matchToken(s2, [COMMA])
            in parseGadtConstructors(s3, ctors ++ [{ name: name, fields: fields }])
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- Parse GADT fields
def parseGadtFields(state: ParserState, fields: List TypeRef) : Result ParseError (List TypeRef, ParserState) =
  if check(state, [IDENT]) then
    match parseTypeRef(state) with
      Ok((typeRef, s1)) -> parseGadtFields(s1, fields ++ [typeRef])
      Err(e) -> Err(e)
  else
    Ok((fields, state))

-- ============ Import Declaration Parsing ============

def parseImportDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  let isPython = check(state, [IDENT]) && getTokenString(current(state)) == "python"
  in let s1 = if isPython then advance(state) else state
  in match expect(s1, IDENT, "Expected module name") with
    Ok((firstPart, s2)) ->
      let firstPartName = getTokenString(firstPart)
      in match parseModulePath(s2, [firstPartName]) with
        Ok((parts, s3)) ->
          let moduleName = String.join(".", parts)
          in let (mAs, s4) = matchToken(s3, [KW_AS])
          in match mAs with
            Just(_) ->
              match expect(s4, IDENT, "Expected alias") with
                Ok((aliasTok, s5)) ->
                  Ok((ImportDecl({
                    module: moduleName,
                    alias: Just(getTokenString(aliasTok)),
                    exposing: Nothing,
                    isPython: isPython
                  }), s5))
                Err(e) -> Err(e)
            Nothing ->
              Ok((ImportDecl({
                module: moduleName,
                alias: Nothing,
                exposing: Nothing,
                isPython: isPython
              }), s4))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse module path (a.b.c)
def parseModulePath(state: ParserState, parts: List String) : Result ParseError (List String, ParserState) =
  let (mDot, s1) = matchToken(state, [DOT])
  in match mDot with
    Just(_) ->
      match expect(s1, IDENT, "Expected module part") with
        Ok((partTok, s2)) ->
          parseModulePath(s2, parts ++ [getTokenString(partTok)])
        Err(e) -> Err(e)
    Nothing -> Ok((parts, state))

-- ============ Interface Declaration Parsing ============

def parseInterfaceDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected interface name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match parseTypeParams(s1) with
        Ok((params, s2)) ->
          match expect(s2, KW_WHERE, "Expected 'where'") with
            Ok((_, s3)) ->
              match expect(s3, LBRACE, "Expected '{'") with
                Ok((_, s4)) ->
                  match parseInterfaceMethods(s4, []) with
                    Ok((methods, s5)) ->
                      match expect(s5, RBRACE, "Expected '}'") with
                        Ok((_, s6)) ->
                          Ok((InterfaceDecl({
                            name: name,
                            params: params,
                            methods: methods,
                            superclasses: []
                          }), s6))
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse interface methods
def parseInterfaceMethods(state: ParserState, methods: List InterfaceMethod) : Result ParseError (List InterfaceMethod, ParserState) =
  if check(state, [RBRACE]) then
    Ok((methods, state))
  else
    match expect(state, IDENT, "Expected method name") with
      Ok((nameTok, s1)) ->
        match expect(s1, COLON, "Expected ':'") with
          Ok((_, s2)) ->
            match parseTypeRef(s2) with
              Ok((typeRef, s3)) ->
                let (mComma, s4) = matchToken(s3, [COMMA])
                in parseInterfaceMethods(s4, methods ++ [{ name: getTokenString(nameTok), typ: typeRef }])
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- ============ Impl Declaration Parsing ============

def parseImplDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected class name") with
    Ok((classNameTok, s1)) ->
      let className = getTokenString(classNameTok)
      in match parseTypeRef(s1) with
        Ok((typeRef, s2)) ->
          match expect(s2, KW_WHERE, "Expected 'where'") with
            Ok((_, s3)) ->
              match expect(s3, LBRACE, "Expected '{'") with
                Ok((_, s4)) ->
                  match parseImplMethods(s4, []) with
                    Ok((methods, s5)) ->
                      match expect(s5, RBRACE, "Expected '}'") with
                        Ok((_, s6)) ->
                          Ok((ImplDecl({
                            className: className,
                            typeRef: typeRef,
                            methods: methods
                          }), s6))
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse impl methods
def parseImplMethods(state: ParserState, methods: List ImplMethod) : Result ParseError (List ImplMethod, ParserState) =
  if check(state, [RBRACE]) then
    Ok((methods, state))
  else
    match expect(state, IDENT, "Expected method name") with
      Ok((nameTok, s1)) ->
        match parseParams(s1) with
          Ok((params, s2)) ->
            match expect(s2, EQUALS, "Expected '='") with
              Ok((_, s3)) ->
                match parseExpr(s3) with
                  Ok((body, s4)) ->
                    let (mComma, s5) = matchToken(s4, [COMMA])
                    in parseImplMethods(s5, methods ++ [{ name: getTokenString(nameTok), params: params, body: body }])
                  Err(e) -> Err(e)
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- ============ Effect Declaration Parsing ============

def parseEffectDecl(state: ParserState) : Result ParseError (Decl, ParserState) =
  match expect(state, IDENT, "Expected effect name") with
    Ok((nameTok, s1)) ->
      let name = getTokenString(nameTok)
      in match expect(s1, LBRACE, "Expected '{'") with
        Ok((_, s2)) ->
          match parseEffectOps(s2, []) with
            Ok((ops, s3)) ->
              match expect(s3, RBRACE, "Expected '}'") with
                Ok((_, s4)) ->
                  Ok((EffectDecl({
                    name: name,
                    operations: ops
                  }), s4))
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse effect operations
def parseEffectOps(state: ParserState, ops: List EffectOp) : Result ParseError (List EffectOp, ParserState) =
  if check(state, [RBRACE]) then
    Ok((ops, state))
  else
    match expect(state, IDENT, "Expected operation name") with
      Ok((nameTok, s1)) ->
        match expect(s1, COLON, "Expected ':'") with
          Ok((_, s2)) ->
            match parseTypeRef(s2) with
              Ok((typeRef, s3)) ->
                let (mComma, s4) = matchToken(s3, [COMMA])
                in parseEffectOps(s4, ops ++ [{ name: getTokenString(nameTok), typ: typeRef }])
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- ============ Type Reference Parsing ============

-- Parse type reference (entry point)
def parseTypeRef(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  parseTypeArrow(state)

-- Parse arrow type (function type)
def parseTypeArrow(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  match parseTypeApp(state) with
    Ok((left, s1)) ->
      let (mArrow, s2) = matchToken(s1, [ARROW])
      in match mArrow with
        Just(_) ->
          match parseTypeArrow(s2) with
            Ok((right, s3)) -> Ok((FunTypeRef({ param: left, result: right }), s3))
            Err(e) -> Err(e)
        Nothing -> Ok((left, s1))
    Err(e) -> Err(e)

-- Parse type application
def parseTypeApp(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  match parseTypeAtom(state) with
    Ok((base, s1)) ->
      match parseTypeArgs(s1, []) with
        Ok((args, s2)) ->
          if List.isEmpty(args) then
            Ok((base, s2))
          else
            match base with
              SimpleTypeRef(data) ->
                Ok((SimpleTypeRef({ name: data.name, args: args }), s2))
              _ -> Ok((base, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse type arguments
def parseTypeArgs(state: ParserState, args: List TypeRef) : Result ParseError (List TypeRef, ParserState) =
  if check(state, [IDENT]) then
    match parseTypeAtom(state) with
      Ok((typeRef, s1)) -> parseTypeArgs(s1, args ++ [typeRef])
      Err(e) -> Err(e)
  else
    Ok((args, state))

-- Parse atomic type
def parseTypeAtom(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  let (mLParen, s1) = matchToken(state, [LPAREN])
  in match mLParen with
    Just(_) ->
      if check(s1, [RPAREN]) then
        Ok((TupleTypeRef({ elements: [] }), advance(s1)))
      else
        match parseTypeRef(s1) with
          Ok((inner, s2)) ->
            let (mComma, s3) = matchToken(s2, [COMMA])
            in match mComma with
              Just(_) ->
                match parseTupleTypes(s3, [inner]) with
                  Ok((elements, s4)) ->
                    match expect(s4, RPAREN, "Expected ')' after tuple type") with
                      Ok((_, s5)) -> Ok((TupleTypeRef({ elements: elements }), s5))
                      Err(e) -> Err(e)
                  Err(e) -> Err(e)
              Nothing ->
                match expect(s2, RPAREN, "Expected ')'") with
                  Ok((_, s3)) -> Ok((inner, s3))
                  Err(e) -> Err(e)
          Err(e) -> Err(e)
    Nothing ->
      let (mLBracket, s2) = matchToken(state, [LBRACKET])
      in match mLBracket with
        Just(_) ->
          match parseTypeRef(s2) with
            Ok((elemType, s3)) ->
              match expect(s3, RBRACKET, "Expected ']' after list type") with
                Ok((_, s4)) -> Ok((SimpleTypeRef({ name: "List", args: [elemType] }), s4))
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Nothing ->
          let (mLBrace, s3) = matchToken(state, [LBRACE])
          in match mLBrace with
            Just(_) -> parseRecordType(s3)
            Nothing ->
              match expect(state, IDENT, "Expected type name") with
                Ok((nameTok, s4)) ->
                  Ok((SimpleTypeRef({ name: getTokenString(nameTok), args: [] }), s4))
                Err(e) -> Err(e)

-- Parse tuple types
def parseTupleTypes(state: ParserState, elements: List TypeRef) : Result ParseError (List TypeRef, ParserState) =
  if check(state, [RPAREN]) then
    Ok((elements, state))
  else
    match parseTypeRef(state) with
      Ok((typeRef, s1)) ->
        let (mComma, s2) = matchToken(s1, [COMMA])
        in parseTupleTypes(s2, elements ++ [typeRef])
      Err(e) -> Err(e)

-- Parse record type
def parseRecordType(state: ParserState) : Result ParseError (TypeRef, ParserState) =
  if check(state, [RBRACE]) then
    match expect(state, RBRACE, "Expected '}' after record type") with
      Ok((_, s1)) -> Ok((RecordTypeRef({ fields: [] }), s1))
      Err(e) -> Err(e)
  else
    match parseRecordFields(state, []) with
      Ok((fields, s1)) ->
        match expect(s1, RBRACE, "Expected '}' after record type") with
          Ok((_, s2)) -> Ok((RecordTypeRef({ fields: fields }), s2))
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- Parse record fields
def parseRecordFields(state: ParserState, fields: List (String, TypeRef)) : Result ParseError (List (String, TypeRef), ParserState) =
  match expect(state, IDENT, "Expected field name") with
    Ok((nameTok, s1)) ->
      match expect(s1, COLON, "Expected ':' after field name") with
        Ok((_, s2)) ->
          match parseTypeRef(s2) with
            Ok((typeRef, s3)) ->
              let (mComma, s4) = matchToken(s3, [COMMA])
              in if check(s4, [RBRACE]) then
                Ok((fields ++ [(getTokenString(nameTok), typeRef)], s4))
              else
                parseRecordFields(s4, fields ++ [(getTokenString(nameTok), typeRef)])
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- ============ Expression Parsing ============

-- Parse expression (entry point)
def parseExpr(state: ParserState) : Result ParseError (Expr, ParserState) =
  parseLet(state)

-- Parse let expression
def parseLet(state: ParserState) : Result ParseError (Expr, ParserState) =
  let (mLet, s1) = matchToken(state, [KW_LET])
  in match mLet with
    Just(_) ->
      match expect(s1, IDENT, "Expected variable name") with
        Ok((nameTok, s2)) ->
          let name = getTokenString(nameTok)
          in match parseLetParams(s2, []) with
            Ok((params, s3)) ->
              match expect(s3, EQUALS, "Expected '=' after let binding") with
                Ok((_, s4)) ->
                  match parseExpr(s4) with
                    Ok((value, s5)) ->
                      let (mIn, s6) = matchToken(s5, [KW_IN])
                      in match parseExpr(s6) with
                        Ok((body, s7)) ->
                          if List.isEmpty(params) then
                            Ok((Let({ name: name, value: value, body: body }), s7))
                          else
                            Ok((LetFunc({ name: name, params: params, value: value, body: body }), s7))
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Nothing -> parseDo(state)

-- Parse let parameters
def parseLetParams(state: ParserState, params: List Param) : Result ParseError (List Param, ParserState) =
  if check(state, [IDENT, LPAREN]) then
    let (mLParen, s1) = matchToken(state, [LPAREN])
    in match mLParen with
      Just(_) ->
        match parseParam(s1) with
          Ok((param, s2)) ->
            match expect(s2, RPAREN, "Expected ')'") with
              Ok((_, s3)) -> parseLetParams(s3, params ++ [param])
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Nothing ->
        match parseParam(state) with
          Ok((param, s1)) -> parseLetParams(s1, params ++ [param])
          Err(e) -> Err(e)
  else
    Ok((params, state))

-- Parse do notation
def parseDo(state: ParserState) : Result ParseError (Expr, ParserState) =
  let (mDo, s1) = matchToken(state, [KW_DO])
  in match mDo with
    Just(_) ->
      match parseDoBindings(s1, []) with
        Ok((bindings, s2)) ->
          let (mIn, s3) = matchToken(s2, [KW_IN])
          in match parseExpr(s3) with
            Ok((body, s4)) -> Ok((DoNotation({ bindings: bindings, body: body }), s4))
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Nothing -> parseIf(state)

-- Parse do bindings
def parseDoBindings(state: ParserState, bindings: List DoBinding) : Result ParseError (List DoBinding, ParserState) =
  if check(state, [KW_IN]) then
    Ok((bindings, state))
  else
    match expect(state, IDENT, "Expected variable name in do binding") with
      Ok((nameTok, s1)) ->
        let (mArrow, s2) = matchToken(s1, [LEFT_ARROW])
        in match parseExpr(s2) with
          Ok((value, s3)) ->
            parseDoBindings(s3, bindings ++ [{ name: getTokenString(nameTok), value: value }])
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- Parse if expression
def parseIf(state: ParserState) : Result ParseError (Expr, ParserState) =
  let (mIf, s1) = matchToken(state, [KW_IF])
  in match mIf with
    Just(_) ->
      match parseExpr(s1) with
        Ok((cond, s2)) ->
          match expect(s2, KW_THEN, "Expected 'then'") with
            Ok((_, s3)) ->
              match parseExpr(s3) with
                Ok((thenBranch, s4)) ->
                  match expect(s4, KW_ELSE, "Expected 'else'") with
                    Ok((_, s5)) ->
                      match parseExpr(s5) with
                        Ok((elseBranch, s6)) ->
                          Ok((If({ cond: cond, thenBranch: thenBranch, elseBranch: elseBranch }), s6))
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Nothing -> parseMatch(state)

-- Parse match expression
def parseMatch(state: ParserState) : Result ParseError (Expr, ParserState) =
  let (mMatch, s1) = matchToken(state, [KW_MATCH])
  in match mMatch with
    Just(_) ->
      match parseExpr(s1) with
        Ok((scrutinee, s2)) ->
          match expect(s2, KW_WITH, "Expected 'with'") with
            Ok((_, s3)) ->
              match parseMatchCases(s3, []) with
                Ok((cases, s4)) -> Ok((Match({ scrutinee: scrutinee, cases: cases }), s4))
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Nothing -> parseOr(state)

-- Parse match cases
def parseMatchCases(state: ParserState, cases: List MatchCase) : Result ParseError (List MatchCase, ParserState) =
  let (mPipe, s1) = matchToken(state, [PIPE])
  in match mPipe with
    Just(_) ->
      match parsePattern(s1) with
        Ok((pattern, s2)) ->
          let (mGuard, s3) = matchToken(s2, [KW_IF])
          in match mGuard with
            Just(_) ->
              match parseExpr(s3) with
                Ok((guard, s4)) ->
                  match expect(s4, ARROW, "Expected '->'") with
                    Ok((_, s5)) ->
                      match parseExpr(s5) with
                        Ok((body, s6)) ->
                          parseMatchCases(s6, cases ++ [{ pattern: pattern, body: body, guard: Just(guard) }])
                        Err(e) -> Err(e)
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
            Nothing ->
              match expect(s3, ARROW, "Expected '->'") with
                Ok((_, s4)) ->
                  match parseExpr(s4) with
                    Ok((body, s5)) ->
                      parseMatchCases(s5, cases ++ [{ pattern: pattern, body: body, guard: Nothing }])
                    Err(e) -> Err(e)
                Err(e) -> Err(e)
        Err(e) -> Err(e)
    Nothing -> Ok((cases, state))

-- Parse or expression (||)
def parseOr(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseAnd(state) with
    Ok((left, s1)) ->
      match parseOrLoop(s1, left) with
        Ok((expr, s2)) -> Ok((expr, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def parseOrLoop(state: ParserState, left: Expr) : Result ParseError (Expr, ParserState) =
  let (mOr, s1) = matchToken(state, [DOUBLE_PIPE])
  in match mOr with
    Just(_) ->
      match parseAnd(s1) with
        Ok((right, s2)) -> parseOrLoop(s2, BinOp({ left: left, op: "||", right: right }))
        Err(e) -> Err(e)
    Nothing -> Ok((left, state))

-- Parse and expression (&&)
def parseAnd(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseComparison(state) with
    Ok((left, s1)) ->
      match parseAndLoop(s1, left) with
        Ok((expr, s2)) -> Ok((expr, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def parseAndLoop(state: ParserState, left: Expr) : Result ParseError (Expr, ParserState) =
  let (mAnd, s1) = matchToken(state, [DOUBLE_AMP])
  in match mAnd with
    Just(_) ->
      match parseComparison(s1) with
        Ok((right, s2)) -> parseAndLoop(s2, BinOp({ left: left, op: "&&", right: right }))
        Err(e) -> Err(e)
    Nothing -> Ok((left, state))

-- Parse comparison expression
def parseComparison(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseCons(state) with
    Ok((left, s1)) ->
      match parseComparisonLoop(s1, left) with
        Ok((expr, s2)) -> Ok((expr, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def parseComparisonLoop(state: ParserState, left: Expr) : Result ParseError (Expr, ParserState) =
  let (mOp, s1) = matchToken(state, [EQ, NEQ, LT, LE, GT, GE])
  in match mOp with
    Just(opTok) ->
      match parseCons(s1) with
        Ok((right, s2)) ->
          let op = getTokenString(opTok)
          in parseComparisonLoop(s2, BinOp({ left: left, op: op, right: right }))
        Err(e) -> Err(e)
    Nothing -> Ok((left, state))

-- Parse cons expression (::)
def parseCons(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseConcat(state) with
    Ok((left, s1)) ->
      let (mCons, s2) = matchToken(s1, [DOUBLE_COLON])
      in match mCons with
        Just(_) ->
          match parseCons(s2) with
            Ok((right, s3)) -> Ok((BinOp({ left: left, op: "::", right: right }), s3))
            Err(e) -> Err(e)
        Nothing -> Ok((left, s1))
    Err(e) -> Err(e)

-- Parse concat expression (++)
def parseConcat(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseAdditive(state) with
    Ok((left, s1)) ->
      match parseConcatLoop(s1, left) with
        Ok((expr, s2)) -> Ok((expr, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def parseConcatLoop(state: ParserState, left: Expr) : Result ParseError (Expr, ParserState) =
  let (mConcat, s1) = matchToken(state, [DOUBLE_PLUS])
  in match mConcat with
    Just(_) ->
      match parseAdditive(s1) with
        Ok((right, s2)) -> parseConcatLoop(s2, BinOp({ left: left, op: "++", right: right }))
        Err(e) -> Err(e)
    Nothing -> Ok((left, state))

-- Parse additive expression (+, -)
def parseAdditive(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseMultiplicative(state) with
    Ok((left, s1)) ->
      match parseAdditiveLoop(s1, left) with
        Ok((expr, s2)) -> Ok((expr, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def parseAdditiveLoop(state: ParserState, left: Expr) : Result ParseError (Expr, ParserState) =
  let (mOp, s1) = matchToken(state, [PLUS, MINUS])
  in match mOp with
    Just(opTok) ->
      match parseMultiplicative(s1) with
        Ok((right, s2)) ->
          let op = getTokenString(opTok)
          in parseAdditiveLoop(s2, BinOp({ left: left, op: op, right: right }))
        Err(e) -> Err(e)
    Nothing -> Ok((left, state))

-- Parse multiplicative expression (*, /, %)
def parseMultiplicative(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseUnary(state) with
    Ok((left, s1)) ->
      match parseMultiplicativeLoop(s1, left) with
        Ok((expr, s2)) -> Ok((expr, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def parseMultiplicativeLoop(state: ParserState, left: Expr) : Result ParseError (Expr, ParserState) =
  let (mOp, s1) = matchToken(state, [STAR, SLASH, PERCENT])
  in match mOp with
    Just(opTok) ->
      match parseUnary(s1) with
        Ok((right, s2)) ->
          let op = getTokenString(opTok)
          in parseMultiplicativeLoop(s2, BinOp({ left: left, op: op, right: right }))
        Err(e) -> Err(e)
    Nothing -> Ok((left, state))

-- Parse unary expression (-, !)
def parseUnary(state: ParserState) : Result ParseError (Expr, ParserState) =
  let (mOp, s1) = matchToken(state, [MINUS, BANG])
  in match mOp with
    Just(opTok) ->
      match parseUnary(s1) with
        Ok((operand, s2)) ->
          let op = getTokenString(opTok)
          in Ok((UnaryOp({ op: op, operand: operand }), s2))
        Err(e) -> Err(e)
    Nothing -> parseApplication(state)

-- Parse function application
def parseApplication(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseAccess(state) with
    Ok((expr, s1)) ->
      match parseApplicationLoop(s1, expr) with
        Ok((result, s2)) -> Ok((result, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def parseApplicationLoop(state: ParserState, expr: Expr) : Result ParseError (Expr, ParserState) =
  let (mLParen, s1) = matchToken(state, [LPAREN])
  in match mLParen with
    Just(_) ->
      if check(s1, [RPAREN]) then
        parseApplicationLoop(advance(s1), expr)
      else
        match parseAppArgs(s1, []) with
          Ok((args, s2)) ->
            match expect(s2, RPAREN, "Expected ')'") with
              Ok((_, s3)) ->
                let applied = applyArgs(expr, args)
                in parseApplicationLoop(s3, applied)
              Err(e) -> Err(e)
          Err(e) -> Err(e)
    Nothing -> Ok((expr, state))

-- Parse application arguments
def parseAppArgs(state: ParserState, args: List Expr) : Result ParseError (List Expr, ParserState) =
  match parseExpr(state) with
    Ok((arg, s1)) ->
      let (mComma, s2) = matchToken(s1, [COMMA])
      in match mComma with
        Just(_) -> parseAppArgs(s2, args ++ [arg])
        Nothing -> Ok((args ++ [arg], s1))
    Err(e) -> Err(e)

-- Apply arguments to expression
def applyArgs(func: Expr, args: List Expr) : Expr =
  match args with
    [] -> func
    [arg] -> App({ func: func, args: [arg] })
    [arg, ...rest] -> applyArgs(App({ func: func, args: [arg] }), rest)

-- Parse field/index access
def parseAccess(state: ParserState) : Result ParseError (Expr, ParserState) =
  match parseAtom(state) with
    Ok((expr, s1)) ->
      match parseAccessLoop(s1, expr) with
        Ok((result, s2)) -> Ok((result, s2))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def parseAccessLoop(state: ParserState, expr: Expr) : Result ParseError (Expr, ParserState) =
  let (mDot, s1) = matchToken(state, [DOT])
  in match mDot with
    Just(_) ->
      match expect(s1, IDENT, "Expected field name") with
        Ok((fieldTok, s2)) ->
          parseAccessLoop(s2, FieldAccess({ expr: expr, field: getTokenString(fieldTok) }))
        Err(e) -> Err(e)
    Nothing ->
      let (mLBracket, s2) = matchToken(state, [LBRACKET])
      in match mLBracket with
        Just(_) ->
          match parseExpr(s2) with
            Ok((index, s3)) ->
              match expect(s3, RBRACKET, "Expected ']'") with
                Ok((_, s4)) -> parseAccessLoop(s4, IndexAccess({ expr: expr, index: index }))
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Nothing -> Ok((expr, state))

-- Parse atomic expression
def parseAtom(state: ParserState) : Result ParseError (Expr, ParserState) =
  -- Integer literal
  let (mInt, s1) = matchToken(state, [INT])
  in match mInt with
    Just(tok) -> Ok((IntLit(getTokenInt(tok)), s1))
    Nothing ->
      -- Float literal
      let (mFloat, s2) = matchToken(state, [FLOAT])
      in match mFloat with
        Just(tok) -> Ok((FloatLit(getTokenFloat(tok)), s2))
        Nothing ->
          -- String literal
          let (mString, s3) = matchToken(state, [STRING])
          in match mString with
            Just(tok) -> Ok((StringLit(getTokenString(tok)), s3))
            Nothing ->
              -- Char literal
              let (mChar, s4) = matchToken(state, [CHAR])
              in match mChar with
                Just(tok) -> Ok((CharLit(getTokenChar(tok)), s4))
                Nothing ->
                  -- Bool literals
                  let (mTrue, s5) = matchToken(state, [TRUE])
                  in match mTrue with
                    Just(_) -> Ok((BoolLit(True), s5))
                    Nothing ->
                      let (mFalse, s6) = matchToken(state, [FALSE])
                      in match mFalse with
                        Just(_) -> Ok((BoolLit(False), s6))
                        Nothing ->
                          -- Lambda
                          let (mFn, s7) = matchToken(state, [KW_FN])
                          in match mFn with
                            Just(_) -> parseLambda(s7)
                            Nothing ->
                              -- Parenthesized expression or tuple
                              let (mLParen, s8) = matchToken(state, [LPAREN])
                              in match mLParen with
                                Just(_) ->
                                  if check(s8, [RPAREN]) then
                                    Ok((UnitLit, advance(s8)))
                                  else
                                    match parseExpr(s8) with
                                      Ok((first, s9)) ->
                                        let (mComma, s10) = matchToken(s9, [COMMA])
                                        in match mComma with
                                          Just(_) ->
                                            match parseTupleElements(s10, [first]) with
                                              Ok((elements, s11)) ->
                                                match expect(s11, RPAREN, "Expected ')'") with
                                                  Ok((_, s12)) -> Ok((TupleLit(elements), s12))
                                                  Err(e) -> Err(e)
                                              Err(e) -> Err(e)
                                          Nothing ->
                                            match expect(s9, RPAREN, "Expected ')'") with
                                              Ok((_, s10)) -> Ok((first, s10))
                                              Err(e) -> Err(e)
                                      Err(e) -> Err(e)
                                Nothing ->
                                  -- List literal
                                  let (mLBracket, s9) = matchToken(state, [LBRACKET])
                                  in match mLBracket with
                                    Just(_) ->
                                      if check(s9, [RBRACKET]) then
                                        Ok((ListLit([]), advance(s9)))
                                      else
                                        match parseListElements(s9, []) with
                                          Ok((elements, s10)) ->
                                            match expect(s10, RBRACKET, "Expected ']'") with
                                              Ok((_, s11)) -> Ok((ListLit(elements), s11))
                                              Err(e) -> Err(e)
                                          Err(e) -> Err(e)
                                    Nothing ->
                                      -- Record literal
                                      let (mLBrace, s10) = matchToken(state, [LBRACE])
                                      in match mLBrace with
                                        Just(_) -> parseRecord(s10)
                                        Nothing ->
                                          -- Variable
                                          match expect(state, IDENT, "Unexpected token") with
                                            Ok((nameTok, s11)) -> Ok((Var(getTokenString(nameTok)), s11))
                                            Err(e) -> Err(e)

-- Parse lambda
def parseLambda(state: ParserState) : Result ParseError (Expr, ParserState) =
  let (mLParen, s1) = matchToken(state, [LPAREN])
  in match mLParen with
    Just(_) ->
      if check(s1, [RPAREN]) then
        match expect(advance(s1), FAT_ARROW, "Expected '=>'") with
          Ok((_, s2)) ->
            match parseExpr(s2) with
              Ok((body, s3)) -> Ok((Lambda({ params: [], body: body }), s3))
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      else
        match parseLambdaParams(s1, []) with
          Ok((params, s2)) ->
            match expect(s2, RPAREN, "Expected ')'") with
              Ok((_, s3)) ->
                match expect(s3, FAT_ARROW, "Expected '=>'") with
                  Ok((_, s4)) ->
                    match parseExpr(s4) with
                      Ok((body, s5)) -> Ok((Lambda({ params: params, body: body }), s5))
                      Err(e) -> Err(e)
                  Err(e) -> Err(e)
              Err(e) -> Err(e)
          Err(e) -> Err(e)
    Nothing ->
      match parseLambdaParamsNoParens(state, []) with
        Ok((params, s1)) ->
          match expect(s1, FAT_ARROW, "Expected '=>'") with
            Ok((_, s2)) ->
              match parseExpr(s2) with
                Ok((body, s3)) -> Ok((Lambda({ params: params, body: body }), s3))
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Err(e) -> Err(e)

-- Parse lambda parameters inside parentheses
def parseLambdaParams(state: ParserState, params: List Param) : Result ParseError (List Param, ParserState) =
  match parseParam(state) with
    Ok((param, s1)) ->
      let (mComma, s2) = matchToken(s1, [COMMA])
      in match mComma with
        Just(_) -> parseLambdaParams(s2, params ++ [param])
        Nothing -> Ok((params ++ [param], s1))
    Err(e) -> Err(e)

-- Parse lambda parameters without parentheses
def parseLambdaParamsNoParens(state: ParserState, params: List Param) : Result ParseError (List Param, ParserState) =
  if check(state, [IDENT]) then
    let peekTok = peek(state)
    in if List.member(peekTok.tokenType, [IDENT, FAT_ARROW, COLON, LPAREN]) then
      match parseParam(state) with
        Ok((param, s1)) -> parseLambdaParamsNoParens(s1, params ++ [param])
        Err(e) -> Err(e)
    else
      Ok((params, state))
  else
    Ok((params, state))

-- Parse tuple elements
def parseTupleElements(state: ParserState, elements: List Expr) : Result ParseError (List Expr, ParserState) =
  if check(state, [RPAREN]) then
    Ok((elements, state))
  else
    match parseExpr(state) with
      Ok((elem, s1)) ->
        let (mComma, s2) = matchToken(s1, [COMMA])
        in parseTupleElements(s2, elements ++ [elem])
      Err(e) -> Err(e)

-- Parse list elements
def parseListElements(state: ParserState, elements: List Expr) : Result ParseError (List Expr, ParserState) =
  match parseExpr(state) with
    Ok((elem, s1)) ->
      let (mComma, s2) = matchToken(s1, [COMMA])
      in match mComma with
        Just(_) -> parseListElements(s2, elements ++ [elem])
        Nothing -> Ok((elements ++ [elem], s1))
    Err(e) -> Err(e)

-- Parse record literal or update
def parseRecord(state: ParserState) : Result ParseError (Expr, ParserState) =
  if check(state, [IDENT]) && peek(state).tokenType == KW_WITH then
    -- Record update
    match expect(state, IDENT, "Expected record name") with
      Ok((nameTok, s1)) ->
        match expect(s1, KW_WITH, "Expected 'with'") with
          Ok((_, s2)) ->
            match parseRecordUpdates(s2, []) with
              Ok((updates, s3)) ->
                match expect(s3, RBRACE, "Expected '}'") with
                  Ok((_, s4)) ->
                    Ok((RecordUpdate({ record: Var(getTokenString(nameTok)), updates: updates }), s4))
                  Err(e) -> Err(e)
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Err(e) -> Err(e)
  else if check(state, [RBRACE]) then
    Ok((RecordLit([]), advance(state)))
  else
    match parseRecordFieldsExpr(state, []) with
      Ok((fields, s1)) ->
        match expect(s1, RBRACE, "Expected '}'") with
          Ok((_, s2)) -> Ok((RecordLit(fields), s2))
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- Parse record fields for expression
def parseRecordFieldsExpr(state: ParserState, fields: List RecordField) : Result ParseError (List RecordField, ParserState) =
  match expect(state, IDENT, "Expected field name") with
    Ok((nameTok, s1)) ->
      match expect(s1, COLON, "Expected ':'") with
        Ok((_, s2)) ->
          match parseExpr(s2) with
            Ok((value, s3)) ->
              let (mComma, s4) = matchToken(s3, [COMMA])
              in if check(s4, [RBRACE]) then
                Ok((fields ++ [{ name: getTokenString(nameTok), value: value }], s4))
              else
                parseRecordFieldsExpr(s4, fields ++ [{ name: getTokenString(nameTok), value: value }])
            Err(e) -> Err(e)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- Parse record updates
def parseRecordUpdates(state: ParserState, updates: List RecordField) : Result ParseError (List RecordField, ParserState) =
  if check(state, [RBRACE]) then
    Ok((updates, state))
  else
    match expect(state, IDENT, "Expected field name") with
      Ok((nameTok, s1)) ->
        match expect(s1, EQUALS, "Expected '='") with
          Ok((_, s2)) ->
            match parseExpr(s2) with
              Ok((value, s3)) ->
                let (mComma, s4) = matchToken(s3, [COMMA])
                in parseRecordUpdates(s4, updates ++ [{ name: getTokenString(nameTok), value: value }])
              Err(e) -> Err(e)
          Err(e) -> Err(e)
      Err(e) -> Err(e)

-- ============ Pattern Parsing ============

-- Parse pattern (entry point)
def parsePattern(state: ParserState) : Result ParseError (Pattern, ParserState) =
  parseConsPattern(state)

-- Parse cons pattern (::)
def parseConsPattern(state: ParserState) : Result ParseError (Pattern, ParserState) =
  match parseAtomPattern(state) with
    Ok((left, s1)) ->
      let (mCons, s2) = matchToken(s1, [DOUBLE_COLON])
      in match mCons with
        Just(_) ->
          match parseConsPattern(s2) with
            Ok((right, s3)) -> Ok((ConsPattern({ head: left, tail: right }), s3))
            Err(e) -> Err(e)
        Nothing -> Ok((left, s1))
    Err(e) -> Err(e)

-- Parse atomic pattern
def parseAtomPattern(state: ParserState) : Result ParseError (Pattern, ParserState) =
  -- Integer pattern
  let (mInt, s1) = matchToken(state, [INT])
  in match mInt with
    Just(tok) -> Ok((IntPattern(getTokenInt(tok)), s1))
    Nothing ->
      -- Float pattern
      let (mFloat, s2) = matchToken(state, [FLOAT])
      in match mFloat with
        Just(tok) -> Ok((FloatPattern(getTokenFloat(tok)), s2))
        Nothing ->
          -- String pattern
          let (mString, s3) = matchToken(state, [STRING])
          in match mString with
            Just(tok) -> Ok((StringPattern(getTokenString(tok)), s3))
            Nothing ->
              -- Char pattern
              let (mChar, s4) = matchToken(state, [CHAR])
              in match mChar with
                Just(tok) -> Ok((CharPattern(getTokenChar(tok)), s4))
                Nothing ->
                  -- Bool patterns
                  let (mTrue, s5) = matchToken(state, [TRUE])
                  in match mTrue with
                    Just(_) -> Ok((BoolPattern(True), s5))
                    Nothing ->
                      let (mFalse, s6) = matchToken(state, [FALSE])
                      in match mFalse with
                        Just(_) -> Ok((BoolPattern(False), s6))
                        Nothing ->
                          -- Wildcard pattern
                          let (mWildcard, s7) = matchToken(state, [UNDERSCORE])
                          in match mWildcard with
                            Just(_) -> Ok((WildcardPattern, s7))
                            Nothing ->
                              -- List pattern
                              let (mLBracket, s8) = matchToken(state, [LBRACKET])
                              in match mLBracket with
                                Just(_) ->
                                  if check(s8, [RBRACKET]) then
                                    Ok((ListPattern([]), advance(s8)))
                                  else
                                    match parsePatternListElements(s8, []) with
                                      Ok((elements, s9)) ->
                                        match expect(s9, RBRACKET, "Expected ']'") with
                                          Ok((_, s10)) -> Ok((ListPattern(elements), s10))
                                          Err(e) -> Err(e)
                                      Err(e) -> Err(e)
                                Nothing ->
                                  -- Tuple or parenthesized pattern
                                  let (mLParen, s9) = matchToken(state, [LPAREN])
                                  in match mLParen with
                                    Just(_) ->
                                      if check(s9, [RPAREN]) then
                                        Ok((TuplePattern([]), advance(s9)))
                                      else
                                        match parsePattern(s9) with
                                          Ok((first, s10)) ->
                                            let (mComma, s11) = matchToken(s10, [COMMA])
                                            in match mComma with
                                              Just(_) ->
                                                match parsePatternTupleElements(s11, [first]) with
                                                  Ok((elements, s12)) ->
                                                    match expect(s12, RPAREN, "Expected ')'") with
                                                      Ok((_, s13)) -> Ok((TuplePattern(elements), s13))
                                                      Err(e) -> Err(e)
                                                  Err(e) -> Err(e)
                                              Nothing ->
                                                match expect(s10, RPAREN, "Expected ')'") with
                                                  Ok((_, s11)) -> Ok((first, s11))
                                                  Err(e) -> Err(e)
                                          Err(e) -> Err(e)
                                    Nothing ->
                                      -- Variable pattern
                                      match expect(state, IDENT, "Expected pattern") with
                                        Ok((nameTok, s10)) -> Ok((VarPattern(getTokenString(nameTok)), s10))
                                        Err(e) -> Err(e)

-- Parse pattern list elements
def parsePatternListElements(state: ParserState, elements: List Pattern) : Result ParseError (List Pattern, ParserState) =
  match parsePattern(state) with
    Ok((elem, s1)) ->
      let (mComma, s2) = matchToken(s1, [COMMA])
      in match mComma with
        Just(_) -> parsePatternListElements(s2, elements ++ [elem])
        Nothing -> Ok((elements ++ [elem], s1))
    Err(e) -> Err(e)

-- Parse pattern tuple elements
def parsePatternTupleElements(state: ParserState, elements: List Pattern) : Result ParseError (List Pattern, ParserState) =
  if check(state, [RPAREN]) then
    Ok((elements, state))
  else
    match parsePattern(state) with
      Ok((elem, s1)) ->
        let (mComma, s2) = matchToken(s1, [COMMA])
        in parsePatternTupleElements(s2, elements ++ [elem])
      Err(e) -> Err(e)
