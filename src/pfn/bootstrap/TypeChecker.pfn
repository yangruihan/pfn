-- Pfn Bootstrap: TypeChecker
-- Type inference for Pfn language

module Bootstrap.TypeChecker

import Bootstrap.Types (..)
import Bootstrap.AST (..)

-- ============ Type Error ============

type TypeError = {
  message: String
}

def typeError(message: String) : TypeError =
  { message: message }

-- ============ Type Checker State ============

type TypeCheckerState = {
  env: TypeEnv,
  varCounter: Int
}

def initTypeChecker : TypeCheckerState =
  { env: emptyEnv, varCounter: 0 }

-- Generate a fresh type variable
def freshVar(state: TypeCheckerState) : (Type, TypeCheckerState) =
  let name = "t" ++ toString(state.varCounter + 1)
  in (tVar(name), { state with varCounter = state.varCounter + 1 })

-- ============ Instantiation and Generalization ============

-- Instantiate a type scheme with fresh type variables
def instantiate(state: TypeCheckerState, scheme: Scheme) : (Type, TypeCheckerState) =
  if List.isEmpty(scheme.vars) then
    (scheme.type, state)
  else
    instantiateVars(state, scheme.vars, emptySubst, scheme.type)

def instantiateVars(state: TypeCheckerState, vars: List String, subst: Subst, t: Type) : (Type, TypeCheckerState) =
  match vars with
    [] -> (applySubst(subst, t), state)
    [v | rest] ->
      let (tv, s1) = freshVar(state)
      in let newSubst = composeSubst(singletonSubst(v, tv), subst)
      in instantiateVars(s1, rest, newSubst, t)

-- Generalize a type to a scheme
def generalize(env: TypeEnv, t: Type) : Scheme =
  let envVars = freeVarsEnv(env)
  in let typeVars = freeVars(t)
  in let genVars = Set.toList(Set.difference(typeVars, envVars))
  in { vars: genVars, type: t }

-- ============ Type Inference ============

-- Result of type inference
type InferResult = {
  type: Type,
  subst: Subst,
  state: TypeCheckerState
}

def inferResult(t: Type, subst: Subst, state: TypeCheckerState) : InferResult =
  { type: t, subst: subst, state: state }

-- Infer the type of an expression
def infer(state: TypeCheckerState, expr: Expr) : Result TypeError InferResult =
  inferExpr(state, emptySubst, expr)

-- Infer expression type with substitution
def inferExpr(state: TypeCheckerState, subst: Subst, expr: Expr) : Result TypeError InferResult =
  match expr with
    -- Literals
    IntLit(_) -> Ok(inferResult(TInt, subst, state))
    FloatLit(_) -> Ok(inferResult(TFloat, subst, state))
    StringLit(_) -> Ok(inferResult(TString, subst, state))
    CharLit(_) -> Ok(inferResult(TChar, subst, state))
    BoolLit(_) -> Ok(inferResult(TBool, subst, state))
    UnitLit -> Ok(inferResult(TUnit, subst, state))

    -- Variable
    Var(name) ->
      match lookupEnv(state.env, name) with
        Just(scheme) ->
          let (t, s1) = instantiate(state, scheme)
          in Ok(inferResult(t, subst, s1))
        Nothing ->
          Err(typeError("Unbound variable: " ++ name))

    -- Lambda
    Lambda(data) ->
      inferLambda(state, subst, data.params, data.body, [])

    -- Application
    App(data) ->
      inferApp(state, subst, data.func, data.args)

    -- Binary operation
    BinOp(data) ->
      inferBinOp(state, subst, data.left, data.op, data.right)

    -- Unary operation
    UnaryOp(data) ->
      inferUnaryOp(state, subst, data.op, data.operand)

    -- If expression
    If(data) ->
      inferIf(state, subst, data.cond, data.thenBranch, data.elseBranch)

    -- Let expression
    Let(data) ->
      inferLet(state, subst, data.name, data.value, data.body)

    -- Let function
    LetFunc(data) ->
      inferLetFunc(state, subst, data.name, data.params, data.value, data.body)

    -- List literal
    ListLit(elements) ->
      inferList(state, subst, elements)

    -- Tuple literal
    TupleLit(elements) ->
      inferTuple(state, subst, elements)

    -- Match expression
    Match(data) ->
      inferMatch(state, subst, data.scrutinee, data.cases)

    -- Field access
    FieldAccess(data) ->
      let (tv, s1) = freshVar(state)
      in Ok(inferResult(tv, subst, s1))

    -- Index access
    IndexAccess(data) ->
      inferIndexAccess(state, subst, data.expr, data.index)

    -- Other expressions (placeholder)
    _ ->
      let (tv, s1) = freshVar(state)
      in Ok(inferResult(tv, subst, s1))

-- ============ Lambda Inference ============

def inferLambda(state: TypeCheckerState, subst: Subst, params: List Param, body: Expr, paramTypes: List Type) : Result TypeError InferResult =
  match params with
    [] ->
      let resultType = buildFunType(List.reverse(paramTypes), applySubst(subst, inferResult.type))
      in -- Need to infer body first
      inferLambdaBody(state, subst, paramTypes, body)
    [p | rest] ->
      let (tv, s1) = freshVar(state)
      in let newEnv = extendEnv(s1.env, p.name, monoScheme(tv))
      in inferLambda({ s1 with env = newEnv }, subst, rest, body, paramTypes ++ [tv])

def inferLambdaBody(state: TypeCheckerState, subst: Subst, paramTypes: List Type, body: Expr) : Result TypeError InferResult =
  match inferExpr(state, subst, body) with
    Ok(result) ->
      let resultType = buildFunType(List.reverse(paramTypes), result.type)
      in Ok(inferResult(resultType, result.subst, result.state))
    Err(e) -> Err(e)

def buildFunType(params: List Type, result: Type) : Type =
  match params with
    [] -> result
    [p | rest] -> tFun(p, buildFunType(rest, result))

-- ============ Application Inference ============

def inferApp(state: TypeCheckerState, subst: Subst, func: Expr, args: List Expr) : Result TypeError InferResult =
  match inferExpr(state, subst, func) with
    Ok(funcResult) ->
      inferAppArgs(funcResult.state, funcResult.subst, funcResult.type, args)
    Err(e) -> Err(e)

def inferAppArgs(state: TypeCheckerState, subst: Subst, funcType: Type, args: List Expr) : Result TypeError InferResult =
  match args with
    [] -> Ok(inferResult(funcType, subst, state))
    [arg | rest] ->
      match inferExpr(state, subst, arg) with
        Ok(argResult) ->
          let (resultType, s1) = freshVar(argResult.state)
          in match unify(applySubst(argResult.subst, funcType), tFun(applySubst(argResult.subst, argResult.type), resultType)) with
            Just(newSubst) ->
              let composed = composeSubst(newSubst, argResult.subst)
              in inferAppArgs(s1, composed, applySubst(composed, resultType), rest)
            Nothing ->
              Err(typeError("Cannot apply function"))
        Err(e) -> Err(e)

-- ============ Binary Operation Inference ============

def inferBinOp(state: TypeCheckerState, subst: Subst, left: Expr, op: String, right: Expr) : Result TypeError InferResult =
  match inferExpr(state, subst, left) with
    Ok(leftResult) ->
      match inferExpr(leftResult.state, leftResult.subst, right) with
        Ok(rightResult) ->
          inferBinOpType(rightResult.state, rightResult.subst, leftResult.type, op, rightResult.type)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def inferBinOpType(state: TypeCheckerState, subst: Subst, leftType: Type, op: String, rightType: Type) : Result TypeError InferResult =
  -- Arithmetic operators
  if List.member(op, ["+", "-", "*", "/", "%"]) then
    inferArithOp(state, subst, leftType, rightType)
  -- Comparison operators
  else if List.member(op, ["<", "<=", ">", ">="]) then
    inferComparisonOp(state, subst, leftType, rightType)
  -- Equality operators
  else if List.member(op, ["==", "!="]) then
    inferEqualityOp(state, subst, leftType, rightType)
  -- Boolean operators
  else if List.member(op, ["&&", "||"]) then
    inferBooleanOp(state, subst, leftType, rightType)
  -- Concatenation
  else if op == "++" then
    inferConcatOp(state, subst, leftType, rightType)
  -- Cons
  else if op == "::" then
    inferConsOp(state, subst, leftType, rightType)
  else
    Err(typeError("Unknown operator: " ++ op))

def inferArithOp(state: TypeCheckerState, subst: Subst, leftType: Type, rightType: Type) : Result TypeError InferResult =
  match unify(applySubst(subst, leftType), TInt) with
    Just(s1) ->
      let composed = composeSubst(s1, subst)
      in match unify(applySubst(composed, rightType), TInt) with
        Just(s2) -> Ok(inferResult(TInt, composeSubst(s2, composed), state))
        Nothing ->
          match unify(applySubst(composed, leftType), TFloat) with
            Just(s2) ->
              let composed2 = composeSubst(s2, composed)
              in match unify(applySubst(composed2, rightType), TFloat) with
                Just(s3) -> Ok(inferResult(TFloat, composeSubst(s3, composed2), state))
                Nothing -> Err(typeError("Type mismatch in arithmetic"))
            Nothing -> Err(typeError("Expected Int or Float"))
    Nothing ->
      match unify(applySubst(subst, leftType), TFloat) with
        Just(s1) ->
          let composed = composeSubst(s1, subst)
          in match unify(applySubst(composed, rightType), TFloat) with
            Just(s2) -> Ok(inferResult(TFloat, composeSubst(s2, composed), state))
            Nothing -> Err(typeError("Type mismatch in arithmetic"))
        Nothing -> Err(typeError("Expected Int or Float"))

def inferComparisonOp(state: TypeCheckerState, subst: Subst, leftType: Type, rightType: Type) : Result TypeError InferResult =
  match unify(applySubst(subst, leftType), TInt) with
    Just(s1) ->
      let composed = composeSubst(s1, subst)
      in match unify(applySubst(composed, rightType), TInt) with
        Just(s2) -> Ok(inferResult(TBool, composeSubst(s2, composed), state))
        Nothing -> Err(typeError("Type mismatch in comparison"))
    Nothing ->
      match unify(applySubst(subst, leftType), TFloat) with
        Just(s1) ->
          let composed = composeSubst(s1, subst)
          in match unify(applySubst(composed, rightType), TFloat) with
            Just(s2) -> Ok(inferResult(TBool, composeSubst(s2, composed), state))
            Nothing -> Err(typeError("Type mismatch in comparison"))
        Nothing -> Err(typeError("Expected Int or Float"))

def inferEqualityOp(state: TypeCheckerState, subst: Subst, leftType: Type, rightType: Type) : Result TypeError InferResult =
  match unify(applySubst(subst, leftType), applySubst(subst, rightType)) with
    Just(s) -> Ok(inferResult(TBool, composeSubst(s, subst), state))
    Nothing -> Err(typeError("Type mismatch in equality"))

def inferBooleanOp(state: TypeCheckerState, subst: Subst, leftType: Type, rightType: Type) : Result TypeError InferResult =
  match unify(applySubst(subst, leftType), TBool) with
    Just(s1) ->
      let composed = composeSubst(s1, subst)
      in match unify(applySubst(composed, rightType), TBool) with
        Just(s2) -> Ok(inferResult(TBool, composeSubst(s2, composed), state))
        Nothing -> Err(typeError("Expected Bool"))
    Nothing -> Err(typeError("Expected Bool"))

def inferConcatOp(state: TypeCheckerState, subst: Subst, leftType: Type, rightType: Type) : Result TypeError InferResult =
  let (elemType, s1) = freshVar(state)
  in match unify(applySubst(subst, leftType), tList(elemType)) with
    Just(s2) ->
      let composed = composeSubst(s2, subst)
      in match unify(applySubst(composed, rightType), tList(applySubst(composed, elemType))) with
        Just(s3) -> Ok(inferResult(tList(applySubst(composeSubst(s3, composed), elemType)), composeSubst(s3, composed), s1))
        Nothing -> Err(typeError("Type mismatch in ++"))
    Nothing -> Err(typeError("Expected List for ++"))

def inferConsOp(state: TypeCheckerState, subst: Subst, leftType: Type, rightType: Type) : Result TypeError InferResult =
  match unify(applySubst(subst, rightType), tList(leftType)) with
    Just(s) -> Ok(inferResult(tList(applySubst(composeSubst(s, subst), leftType)), composeSubst(s, subst), state))
    Nothing -> Err(typeError("Expected List for ::"))

-- ============ Unary Operation Inference ============

def inferUnaryOp(state: TypeCheckerState, subst: Subst, op: String, operand: Expr) : Result TypeError InferResult =
  match inferExpr(state, subst, operand) with
    Ok(result) ->
      if op == "-" then
        match unify(applySubst(result.subst, result.type), TInt) with
          Just(s) -> Ok(inferResult(TInt, composeSubst(s, result.subst), result.state))
          Nothing ->
            match unify(applySubst(result.subst, result.type), TFloat) with
              Just(s) -> Ok(inferResult(TFloat, composeSubst(s, result.subst), result.state))
              Nothing -> Err(typeError("Expected Int or Float for -"))
      else if op == "!" then
        match unify(applySubst(result.subst, result.type), TBool) with
          Just(s) -> Ok(inferResult(TBool, composeSubst(s, result.subst), result.state))
          Nothing -> Err(typeError("Expected Bool for !"))
      else
        Err(typeError("Unknown unary operator: " ++ op))
    Err(e) -> Err(e)

-- ============ If Inference ============

def inferIf(state: TypeCheckerState, subst: Subst, cond: Expr, thenBranch: Expr, elseBranch: Expr) : Result TypeError InferResult =
  match inferExpr(state, subst, cond) with
    Ok(condResult) ->
      match unify(applySubst(condResult.subst, condResult.type), TBool) with
        Just(s1) ->
          let composed1 = composeSubst(s1, condResult.subst)
          in match inferExpr(condResult.state, composed1, thenBranch) with
            Ok(thenResult) ->
              match inferExpr(thenResult.state, thenResult.subst, elseBranch) with
                Ok(elseResult) ->
                  match unify(applySubst(elseResult.subst, thenResult.type), elseResult.type) with
                    Just(s2) -> Ok(inferResult(applySubst(composeSubst(s2, elseResult.subst), thenResult.type), composeSubst(s2, elseResult.subst), elseResult.state))
                    Nothing -> Err(typeError("If branches must have same type"))
                Err(e) -> Err(e)
            Err(e) -> Err(e)
        Nothing -> Err(typeError("If condition must be Bool"))
    Err(e) -> Err(e)

-- ============ Let Inference ============

def inferLet(state: TypeCheckerState, subst: Subst, name: String, value: Expr, body: Expr) : Result TypeError InferResult =
  match inferExpr(state, subst, value) with
    Ok(valueResult) ->
      let scheme = generalize(valueResult.state.env, applySubst(valueResult.subst, valueResult.type))
      in let newEnv = extendEnv(valueResult.state.env, name, scheme)
      in match inferExpr({ valueResult.state with env = newEnv }, valueResult.subst, body) with
        Ok(bodyResult) -> Ok(bodyResult)
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def inferLetFunc(state: TypeCheckerState, subst: Subst, name: String, params: List Param, value: Expr, body: Expr) : Result TypeError InferResult =
  inferLetFuncParams(state, subst, params, [], value, \s pt vt ->
    let funcType = buildFunType(pt, vt)
    in let scheme = generalize(s.env, funcType)
    in let newEnv = extendEnv(s.env, name, scheme)
    in match inferExpr({ s with env = newEnv }, subst, body) with
      Ok(result) -> Ok(result)
      Err(e) -> Err(e))

def inferLetFuncParams(state: TypeCheckerState, subst: Subst, params: List Param, paramTypes: List Type, value: Expr, cont: TypeCheckerState -> List Type -> Type -> Result TypeError InferResult) : Result TypeError InferResult =
  match params with
    [] ->
      match inferExpr(state, subst, value) with
        Ok(result) -> cont(result.state, paramTypes, applySubst(result.subst, result.type))
        Err(e) -> Err(e)
    [p | rest] ->
      let (tv, s1) = freshVar(state)
      in let newEnv = extendEnv(s1.env, p.name, monoScheme(tv))
      in inferLetFuncParams({ s1 with env = newEnv }, subst, rest, paramTypes ++ [tv], value, cont)

-- ============ List Inference ============

def inferList(state: TypeCheckerState, subst: Subst, elements: List Expr) : Result TypeError InferResult =
  match elements with
    [] ->
      let (tv, s1) = freshVar(state)
      in Ok(inferResult(tList(tv), subst, s1))
    [first | rest] ->
      match inferExpr(state, subst, first) with
        Ok(firstResult) ->
          inferListElements(firstResult.state, firstResult.subst, firstResult.type, rest)
        Err(e) -> Err(e)

def inferListElements(state: TypeCheckerState, subst: Subst, elemType: Type, elements: List Expr) : Result TypeError InferResult =
  match elements with
    [] -> Ok(inferResult(tList(elemType), subst, state))
    [e | rest] ->
      match inferExpr(state, subst, e) with
        Ok(result) ->
          match unify(applySubst(result.subst, elemType), applySubst(result.subst, result.type)) with
            Just(s) ->
              inferListElements(result.state, composeSubst(s, result.subst), applySubst(composeSubst(s, result.subst), elemType), rest)
            Nothing -> Err(typeError("List elements must have same type"))
        Err(e) -> Err(e)

-- ============ Tuple Inference ============

def inferTuple(state: TypeCheckerState, subst: Subst, elements: List Expr) : Result TypeError InferResult =
  inferTupleElements(state, subst, [], elements)

def inferTupleElements(state: TypeCheckerState, subst: Subst, types: List Type, elements: List Expr) : Result TypeError InferResult =
  match elements with
    [] -> Ok(inferResult(tTuple(List.reverse(types)), subst, state))
    [e | rest] ->
      match inferExpr(state, subst, e) with
        Ok(result) ->
          inferTupleElements(result.state, result.subst, [applySubst(result.subst, result.type)] ++ types, rest)
        Err(e) -> Err(e)

-- ============ Match Inference ============

def inferMatch(state: TypeCheckerState, subst: Subst, scrutinee: Expr, cases: List MatchCase) : Result TypeError InferResult =
  match inferExpr(state, subst, scrutinee) with
    Ok(scrutineeResult) ->
      if List.isEmpty(cases) then
        let (tv, s1) = freshVar(scrutineeResult.state)
        in Ok(inferResult(tv, scrutineeResult.subst, s1))
      else
        let (resultType, s1) = freshVar(scrutineeResult.state)
        in inferMatchCases(s1, scrutineeResult.subst, scrutineeResult.type, resultType, cases)
    Err(e) -> Err(e)

def inferMatchCases(state: TypeCheckerState, subst: Subst, scrutineeType: Type, resultType: Type, cases: List MatchCase) : Result TypeError InferResult =
  match cases with
    [] -> Ok(inferResult(applySubst(subst, resultType), subst, state))
    [c | rest] ->
      match inferPattern(state, subst, c.pattern) with
        Ok((patternType, patternEnv, s1)) ->
          match unify(applySubst(s1, scrutineeType), applySubst(s1, patternType)) with
            Just(s2) ->
              let composed = composeSubst(s2, s1)
              in let envWithPattern = mergeEnv(state.env, patternEnv)
              in match inferExpr({ state with env = envWithPattern }, composed, c.body) with
                Ok(bodyResult) ->
                  match unify(applySubst(bodyResult.subst, resultType), bodyResult.type) with
                    Just(s3) ->
                      inferMatchCases(bodyResult.state, composeSubst(s3, bodyResult.subst), applySubst(composeSubst(s3, bodyResult.subst), scrutineeType), applySubst(composeSubst(s3, bodyResult.subst), resultType), rest)
                    Nothing -> Err(typeError("Match cases must have same type"))
                Err(e) -> Err(e)
            Nothing -> Err(typeError("Pattern type mismatch"))
        Err(e) -> Err(e)

-- ============ Pattern Inference ============

def inferPattern(state: TypeCheckerState, subst: Subst, pattern: Pattern) : Result TypeError (Type, TypeEnv, Subst) =
  match pattern with
    IntPattern(_) -> Ok((TInt, emptyEnv, subst))
    FloatPattern(_) -> Ok((TFloat, emptyEnv, subst))
    StringPattern(_) -> Ok((TString, emptyEnv, subst))
    CharPattern(_) -> Ok((TChar, emptyEnv, subst))
    BoolPattern(_) -> Ok((TBool, emptyEnv, subst))
    VarPattern(name) ->
      let (tv, s1) = freshVar(state)
      in Ok((tv, extendEnv(emptyEnv, name, monoScheme(tv)), subst))
    WildcardPattern ->
      let (tv, s1) = freshVar(state)
      in Ok((tv, emptyEnv, subst))
    ListPattern(elements) ->
      inferListPattern(state, subst, elements)
    ConsPattern(data) ->
      inferConsPattern(state, subst, data.head, data.tail)
    TuplePattern(elements) ->
      inferTuplePattern(state, subst, elements)
    _ ->
      let (tv, s1) = freshVar(state)
      in Ok((tv, emptyEnv, subst))

def inferListPattern(state: TypeCheckerState, subst: Subst, elements: List Pattern) : Result TypeError (Type, TypeEnv, Subst) =
  match elements with
    [] ->
      let (tv, s1) = freshVar(state)
      in Ok((tList(tv), emptyEnv, subst))
    [first | rest] ->
      match inferPattern(state, subst, first) with
        Ok((firstType, firstEnv, s1)) ->
          match inferListPatternElements(state, s1, firstType, firstEnv, rest) with
            Ok((elemType, env, s2)) -> Ok((tList(elemType), env, s2))
            Err(e) -> Err(e)
        Err(e) -> Err(e)

def inferListPatternElements(state: TypeCheckerState, subst: Subst, elemType: Type, env: TypeEnv, elements: List Pattern) : Result TypeError (Type, TypeEnv, Subst) =
  match elements with
    [] -> Ok((elemType, env, subst))
    [e | rest] ->
      match inferPattern(state, subst, e) with
        Ok((t, eEnv, s)) ->
          match unify(applySubst(s, elemType), applySubst(s, t)) with
            Just(s2) ->
              inferListPatternElements(state, composeSubst(s2, s), applySubst(composeSubst(s2, s), elemType), mergeEnv(env, eEnv), rest)
            Nothing -> Err(typeError("Pattern elements must have same type"))
        Err(e) -> Err(e)

def inferConsPattern(state: TypeCheckerState, subst: Subst, head: Pattern, tail: Pattern) : Result TypeError (Type, TypeEnv, Subst) =
  match inferPattern(state, subst, head) with
    Ok((headType, headEnv, s1)) ->
      match inferPattern(state, s1, tail) with
        Ok((tailType, tailEnv, s2)) ->
          match unify(applySubst(s2, tailType), tList(applySubst(s2, headType))) with
            Just(s3) -> Ok((tList(applySubst(composeSubst(s3, s2), headType)), mergeEnv(headEnv, tailEnv), composeSubst(s3, s2)))
            Nothing -> Err(typeError("Cons pattern type mismatch"))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

def inferTuplePattern(state: TypeCheckerState, subst: Subst, elements: List Pattern) : Result TypeError (Type, TypeEnv, Subst) =
  inferTuplePatternElements(state, subst, [], emptyEnv, elements)

def inferTuplePatternElements(state: TypeCheckerState, subst: Subst, types: List Type, env: TypeEnv, elements: List Pattern) : Result TypeError (Type, TypeEnv, Subst) =
  match elements with
    [] -> Ok((tTuple(List.reverse(types)), env, subst))
    [e | rest] ->
      match inferPattern(state, subst, e) with
        Ok((t, eEnv, s)) ->
          inferTuplePatternElements(state, s, [applySubst(s, t)] ++ types, mergeEnv(env, eEnv), rest)
        Err(e) -> Err(e)

-- ============ Index Access Inference ============

def inferIndexAccess(state: TypeCheckerState, subst: Subst, expr: Expr, index: Expr) : Result TypeError InferResult =
  match inferExpr(state, subst, expr) with
    Ok(exprResult) ->
      match inferExpr(exprResult.state, exprResult.subst, index) with
        Ok(indexResult) ->
          match unify(applySubst(indexResult.subst, indexResult.type), TInt) with
            Just(s) ->
              let (tv, s1) = freshVar(indexResult.state)
              in Ok(inferResult(tv, composeSubst(s, indexResult.subst), s1))
            Nothing -> Err(typeError("Index must be Int"))
        Err(e) -> Err(e)
    Err(e) -> Err(e)

-- ============ Helpers ============

def mergeEnv(e1: TypeEnv, e2: TypeEnv) : TypeEnv =
  { bindings: Dict.merge(e1.bindings, e2.bindings) }
