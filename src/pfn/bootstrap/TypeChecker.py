from __future__ import annotations

from stdlib import String, List, Dict, Set, Maybe, Result, Just, Nothing, Ok, Err, Record

from stdlib import reverse, _not_

from bootstrap.Types import *

from bootstrap.AST import *

from dataclasses import dataclass

@dataclass
class TypeError:
    message: str

def typeError(message):
    return Record({"message": message})

from dataclasses import dataclass

@dataclass
class TypeCheckerState:
    env: TypeEnv
    varCounter: int

initTypeChecker = Record({"env": emptyEnv, "varCounter": 0})

def freshVar(state):
    return (lambda name: (tVar(name), Record({**state, "varCounter": state.varCounter + 1})))('t' + toString(state.varCounter + 1))

def instantiate(state): return lambda scheme: (scheme.typ, state) if List.isEmpty(scheme.vars) else instantiateVars(state)(scheme.vars)(emptySubst)(scheme.typ)

def instantiateVars(state): return lambda vars: lambda subst: lambda t: (lambda __match_val: ((applySubst(subst)(t), state) if __match_val == [] else (lambda __let_val_0: (lambda newSubst: instantiateVars(__let_val_0[1])(__match_val[1:])(newSubst)(t))(composeSubst(singletonSubst(__match_val[0])(__let_val_0[0]))(subst)) if isinstance(__let_val_0, tuple) and len(__let_val_0) == 2 else None)(freshVar(state))))(vars)

def generalize(env): return lambda t: (lambda envVars: (lambda typeVars: (lambda genVars: Record({"vars": genVars, "typ": t}))(Set.toList(Set.difference(typeVars)(envVars))))(freeVars(t)))(freeVarsEnv(env))

from dataclasses import dataclass

@dataclass
class InferResult:
    typ: Type
    subst: Subst
    state: TypeCheckerState

def inferResult(t): return lambda subst: lambda state: Record({"typ": t, "subst": subst, "state": state})

def infer(state): return lambda expr: inferExpr(state)(emptySubst)(expr)

def inferExpr(state): return lambda subst: lambda expr: (lambda __match_val: (Ok(inferResult(TInt)(subst)(state)) if isinstance(__match_val, IntLit) else (Ok(inferResult(TFloat)(subst)(state)) if isinstance(__match_val, FloatLit) else (Ok(inferResult(TString)(subst)(state)) if isinstance(__match_val, StringLit) else (Ok(inferResult(TChar)(subst)(state)) if isinstance(__match_val, CharLit) else (Ok(inferResult(TBool)(subst)(state)) if isinstance(__match_val, BoolLit) else (Ok(inferResult(TUnit)(subst)(state)) if __match_val is UnitLit else (lambda __match_val: ((lambda __let_val_1: Ok(inferResult(__let_val_1[0])(subst)(__let_val_1[1])) if isinstance(__let_val_1, tuple) and len(__let_val_1) == 2 else None)(instantiate(state)(__match_val._field0)) if isinstance(__match_val, Just) else (Err(typeError('Unbound variable: ' + __match_val._field0)) if __match_val is Nothing else (inferLambda(state)(subst)(__match_val._field0.params)(__match_val._field0.body)([]) if isinstance(__match_val, Lambda) else (inferApp(state)(subst)(__match_val._field0.func)(__match_val._field0.args) if isinstance(__match_val, App) else (inferBinOp(state)(subst)(__match_val._field0.left)(__match_val._field0.op)(__match_val._field0.right) if isinstance(__match_val, BinOp) else (inferUnaryOp(state)(subst)(__match_val._field0.op)(__match_val._field0.operand) if isinstance(__match_val, UnaryOp) else (inferIf(state)(subst)(__match_val._field0.cond)(__match_val._field0.thenBranch)(__match_val._field0.elseBranch) if isinstance(__match_val, If) else (inferLet(state)(subst)(__match_val._field0.__match_val._field0)(__match_val._field0.value)(__match_val._field0.body) if isinstance(__match_val, Let) else (inferLetFunc(state)(subst)(__match_val._field0.__match_val._field0)(__match_val._field0.params)(__match_val._field0.value)(__match_val._field0.body) if isinstance(__match_val, LetFunc) else (inferList(state)(subst)(__match_val._field0) if isinstance(__match_val, ListLit) else (inferTuple(state)(subst)(__match_val._field0) if isinstance(__match_val, TupleLit) else (inferMatch(state)(subst)(__match_val._field0.scrutinee)(__match_val._field0.cases) if isinstance(__match_val, Match) else ((lambda __let_val_2: Ok(inferResult(__let_val_2[0])(subst)(__let_val_2[1])) if isinstance(__let_val_2, tuple) and len(__let_val_2) == 2 else None)(freshVar(state)) if isinstance(__match_val, FieldAccess) else (inferIndexAccess(state)(subst)(__match_val._field0.expr)(__match_val._field0.index) if isinstance(__match_val, IndexAccess) else (lambda __let_val_3: Ok(inferResult(__let_val_3[0])(subst)(__let_val_3[1])) if isinstance(__let_val_3, tuple) and len(__let_val_3) == 2 else None)(freshVar(state)))))))))))))))))(lookupEnv(state.env)(__match_val._field0)))))))))(expr)

def inferLambda(state): return lambda subst: lambda params: lambda body: lambda paramTypes: (lambda __match_val: ((lambda resultType: inferLambdaBody(state)(subst)(paramTypes)(body))(buildFunType(List.reverse(paramTypes))(applySubst(subst)(inferResult.typ))) if __match_val == [] else (lambda __let_val_4: (lambda newEnv: inferLambda(Record({**__let_val_4[1], "env": newEnv}))(subst)(__match_val[1:])(body)(paramTypes + [__let_val_4[0]]))(extendEnv(__let_val_4[1].env)(__match_val[0].name)(monoScheme(__let_val_4[0]))) if isinstance(__let_val_4, tuple) and len(__let_val_4) == 2 else None)(freshVar(state))))(params)

def inferLambdaBody(state): return lambda subst: lambda paramTypes: lambda body: (lambda __match_val: ((lambda resultType: Ok(inferResult(resultType)(__match_val._field0.subst)(__match_val._field0.state)))(buildFunType(List.reverse(paramTypes))(__match_val._field0.typ)) if isinstance(__match_val, Ok) else Err(__match_val._field0)))(inferExpr(state)(subst)(body))

def buildFunType(params): return lambda result: (lambda __match_val: (result if __match_val == [] else tFun(__match_val[0])(buildFunType(__match_val[1:])(result))))(params)

def inferApp(state): return lambda subst: lambda func: lambda args: (lambda __match_val: (inferAppArgs(__match_val._field0.state)(__match_val._field0.subst)(__match_val._field0.typ)(args) if isinstance(__match_val, Ok) else Err(__match_val._field0)))(inferExpr(state)(subst)(func))

def inferAppArgs(state): return lambda subst: lambda funcType: lambda args: (lambda __match_val: (Ok(inferResult(funcType)(subst)(state)) if __match_val == [] else (lambda __match_val: (lambda __let_val_5: (lambda __match_val: ((lambda composed: inferAppArgs(__let_val_5[1])(composed)(applySubst(composed)(__let_val_5[0]))(__match_val[1:]))(composeSubst(__match_val._field0)(__match_val._field0.subst)) if isinstance(__match_val, Just) else (Err(typeError('Cannot apply function')) if __match_val is Nothing else Err(__match_val._field0))))(unify(applySubst(__match_val._field0.subst)(funcType))(tFun(applySubst(__match_val._field0.subst)(__match_val._field0.typ))(__let_val_5[0]))) if isinstance(__let_val_5, tuple) and len(__let_val_5) == 2 else None)(freshVar(__match_val._field0.state)))(inferExpr(state)(subst)(__match_val[0]))))(args)

def inferBinOp(state): return lambda subst: lambda left: lambda op: lambda right: (lambda __match_val: (lambda __match_val: (inferBinOpType(__match_val._field0.state)(__match_val._field0.subst)(__match_val._field0.typ)(op)(__match_val._field0.typ) if isinstance(__match_val, Ok) else (Err(__match_val._field0) if isinstance(__match_val, Err) else Err(__match_val._field0))))(inferExpr(__match_val._field0.state)(__match_val._field0.subst)(right)))(inferExpr(state)(subst)(left))

def inferBinOpType(state): return lambda subst: lambda leftType: lambda op: lambda rightType: inferArithOp(state)(subst)(leftType)(rightType) if List.member(op)(['+', '-', '*', '/', '%']) else inferComparisonOp(state)(subst)(leftType)(rightType) if List.member(op)(['<', '<=', '>', '>=']) else inferEqualityOp(state)(subst)(leftType)(rightType) if List.member(op)(['==', '!=']) else inferBooleanOp(state)(subst)(leftType)(rightType) if List.member(op)(['&&', '||']) else inferConcatOp(state)(subst)(leftType)(rightType) if op == '++' else inferConsOp(state)(subst)(leftType)(rightType) if op == '::' else Err(typeError('Unknown operator: ' + op))

def inferArithOp(state): return lambda subst: lambda leftType: lambda rightType: (lambda __match_val: (lambda composed: (lambda __match_val: (Ok(inferResult(TInt)(composeSubst(__match_val._field0)(composed))(state)) if isinstance(__match_val, Just) else (lambda __match_val: (lambda composed2: (lambda __match_val: (Ok(inferResult(TFloat)(composeSubst(__match_val._field0)(composed2))(state)) if isinstance(__match_val, Just) else (Err(typeError('Type mismatch in arithmetic')) if __match_val is Nothing else (Err(typeError('Expected Int or Float')) if __match_val is Nothing else (lambda __match_val: (lambda composed: (lambda __match_val: (Ok(inferResult(TFloat)(composeSubst(__match_val._field0)(composed))(state)) if isinstance(__match_val, Just) else (Err(typeError('Type mismatch in arithmetic')) if __match_val is Nothing else Err(typeError('Expected Int or Float')))))(unify(applySubst(composed)(rightType))(TFloat)))(composeSubst(__match_val._field0)(subst)))(unify(applySubst(subst)(leftType))(TFloat))))))(unify(applySubst(composed2)(rightType))(TFloat)))(composeSubst(__match_val._field0)(composed)))(unify(applySubst(composed)(leftType))(TFloat))))(unify(applySubst(composed)(rightType))(TInt)))(composeSubst(__match_val._field0)(subst)))(unify(applySubst(subst)(leftType))(TInt))

def inferComparisonOp(state): return lambda subst: lambda leftType: lambda rightType: (lambda __match_val: (lambda composed: (lambda __match_val: (Ok(inferResult(TBool)(composeSubst(__match_val._field0)(composed))(state)) if isinstance(__match_val, Just) else (Err(typeError('Type mismatch in comparison')) if __match_val is Nothing else (lambda __match_val: (lambda composed: (lambda __match_val: (Ok(inferResult(TBool)(composeSubst(__match_val._field0)(composed))(state)) if isinstance(__match_val, Just) else (Err(typeError('Type mismatch in comparison')) if __match_val is Nothing else Err(typeError('Expected Int or Float')))))(unify(applySubst(composed)(rightType))(TFloat)))(composeSubst(__match_val._field0)(subst)))(unify(applySubst(subst)(leftType))(TFloat)))))(unify(applySubst(composed)(rightType))(TInt)))(composeSubst(__match_val._field0)(subst)))(unify(applySubst(subst)(leftType))(TInt))

def inferEqualityOp(state): return lambda subst: lambda leftType: lambda rightType: (lambda __match_val: (Ok(inferResult(TBool)(composeSubst(__match_val._field0)(subst))(state)) if isinstance(__match_val, Just) else Err(typeError('Type mismatch in equality'))))(unify(applySubst(subst)(leftType))(applySubst(subst)(rightType)))

def inferBooleanOp(state): return lambda subst: lambda leftType: lambda rightType: (lambda __match_val: (lambda composed: (lambda __match_val: (Ok(inferResult(TBool)(composeSubst(__match_val._field0)(composed))(state)) if isinstance(__match_val, Just) else (Err(typeError('Expected Bool')) if __match_val is Nothing else Err(typeError('Expected Bool')))))(unify(applySubst(composed)(rightType))(TBool)))(composeSubst(__match_val._field0)(subst)))(unify(applySubst(subst)(leftType))(TBool))

def inferConcatOp(state): return lambda subst: lambda leftType: lambda rightType: (lambda __let_val_6: (lambda __match_val: (lambda composed: (lambda __match_val: (Ok(inferResult(tList(applySubst(composeSubst(__match_val._field0)(composed))(__let_val_6[0])))(composeSubst(__match_val._field0)(composed))(__let_val_6[1])) if isinstance(__match_val, Just) else (Err(typeError('Type mismatch in ++')) if __match_val is Nothing else Err(typeError('Expected List for ++')))))(unify(applySubst(composed)(rightType))(tList(applySubst(composed)(__let_val_6[0])))))(composeSubst(__match_val._field0)(subst)))(unify(applySubst(subst)(leftType))(tList(__let_val_6[0]))) if isinstance(__let_val_6, tuple) and len(__let_val_6) == 2 else None)(freshVar(state))

def inferConsOp(state): return lambda subst: lambda leftType: lambda rightType: (lambda __match_val: (Ok(inferResult(tList(applySubst(composeSubst(__match_val._field0)(subst))(leftType)))(composeSubst(__match_val._field0)(subst))(state)) if isinstance(__match_val, Just) else Err(typeError('Expected List for ::'))))(unify(applySubst(subst)(rightType))(tList(leftType)))

def inferUnaryOp(state): return lambda subst: lambda op: lambda operand: (lambda __match_val: ((lambda __match_val: (Ok(inferResult(TInt)(composeSubst(__match_val._field0)(__match_val._field0.subst))(__match_val._field0.state)) if isinstance(__match_val, Just) else (lambda __match_val: (Ok(inferResult(TFloat)(composeSubst(__match_val._field0)(__match_val._field0.subst))(__match_val._field0.state)) if isinstance(__match_val, Just) else Err(typeError('Expected Int or Float for -'))))(unify(applySubst(__match_val._field0.subst)(__match_val._field0.typ))(TFloat))))(unify(applySubst(__match_val._field0.subst)(__match_val._field0.typ))(TInt)) if op == '-' else (lambda __match_val: (Ok(inferResult(TBool)(composeSubst(__match_val._field0)(__match_val._field0.subst))(__match_val._field0.state)) if isinstance(__match_val, Just) else Err(typeError('Expected Bool for !'))))(unify(applySubst(__match_val._field0.subst)(__match_val._field0.typ))(TBool)) if op == '!' else Err(typeError('Unknown unary operator: ' + op)) if isinstance(__match_val, Ok) else Err(__match_val._field0)))(inferExpr(state)(subst)(operand))

def inferIf(state): return lambda subst: lambda cond: lambda thenBranch: lambda elseBranch: (lambda __match_val: (lambda __match_val: (lambda composed1: (lambda __match_val: (lambda __match_val: (lambda __match_val: (Ok(inferResult(applySubst(composeSubst(__match_val._field0)(__match_val._field0.subst))(__match_val._field0.typ))(composeSubst(__match_val._field0)(__match_val._field0.subst))(__match_val._field0.state)) if isinstance(__match_val, Just) else (Err(typeError('If branches must have same type')) if __match_val is Nothing else (Err(__match_val._field0) if isinstance(__match_val, Err) else (Err(__match_val._field0) if isinstance(__match_val, Err) else (Err(typeError('If condition must be Bool')) if __match_val is Nothing else Err(__match_val._field0)))))))(unify(applySubst(__match_val._field0.subst)(__match_val._field0.typ))(__match_val._field0.typ)))(inferExpr(__match_val._field0.state)(__match_val._field0.subst)(elseBranch)))(inferExpr(__match_val._field0.state)(composed1)(thenBranch)))(composeSubst(__match_val._field0)(__match_val._field0.subst)))(unify(applySubst(__match_val._field0.subst)(__match_val._field0.typ))(TBool)))(inferExpr(state)(subst)(cond))

def inferLet(state): return lambda subst: lambda name: lambda value: lambda body: (lambda __match_val: (lambda scheme: (lambda newEnv: (lambda __match_val: (Ok(__match_val._field0) if isinstance(__match_val, Ok) else (Err(__match_val._field0) if isinstance(__match_val, Err) else Err(__match_val._field0))))(inferExpr(Record({**__match_val._field0.state, "env": newEnv}))(__match_val._field0.subst)(body)))(extendEnv(__match_val._field0.state.env)(name)(scheme)))(generalize(__match_val._field0.state.env)(applySubst(__match_val._field0.subst)(__match_val._field0.typ))))(inferExpr(state)(subst)(value))

def inferLetFunc(state): return lambda subst: lambda name: lambda params: lambda value: lambda body: inferLetFuncParams(state)(subst)(params)([])(value)(lambda s: lambda pt: lambda vt: (lambda funcType: (lambda scheme: (lambda newEnv: (lambda __match_val: (Ok(__match_val._field0) if isinstance(__match_val, Ok) else Err(__match_val._field0)))(inferExpr(Record({**s, "env": newEnv}))(subst)(body)))(extendEnv(s.env)(name)(scheme)))(generalize(s.env)(funcType)))(buildFunType(pt)(vt)))

def inferLetFuncParams(state): return lambda subst: lambda params: lambda paramTypes: lambda value: lambda cont: (lambda __match_val: (lambda __match_val: (cont(__match_val._field0.state)(paramTypes)(applySubst(__match_val._field0.subst)(__match_val._field0.typ)) if isinstance(__match_val, Ok) else (Err(__match_val._field0) if isinstance(__match_val, Err) else (lambda __let_val_7: (lambda newEnv: inferLetFuncParams(Record({**__let_val_7[1], "env": newEnv}))(subst)(__match_val[1:])(paramTypes + [__let_val_7[0]])(value)(cont))(extendEnv(__let_val_7[1].env)(__match_val[0].name)(monoScheme(__let_val_7[0]))) if isinstance(__let_val_7, tuple) and len(__let_val_7) == 2 else None)(freshVar(state)))))(inferExpr(state)(subst)(value)))(params)

def inferList(state): return lambda subst: lambda elements: (lambda __match_val: ((lambda __let_val_8: Ok(inferResult(tList(__let_val_8[0]))(subst)(__let_val_8[1])) if isinstance(__let_val_8, tuple) and len(__let_val_8) == 2 else None)(freshVar(state)) if __match_val == [] else (lambda __match_val: (inferListElements(__match_val._field0.state)(__match_val._field0.subst)(__match_val._field0.typ)(__match_val[1:]) if isinstance(__match_val, Ok) else Err(__match_val._field0)))(inferExpr(state)(subst)(__match_val[0]))))(elements)

def inferListElements(state): return lambda subst: lambda elemType: lambda elements: (lambda __match_val: (Ok(inferResult(tList(elemType))(subst)(state)) if __match_val == [] else (lambda __match_val: (lambda __match_val: (inferListElements(__match_val._field0.state)(composeSubst(__match_val._field0)(__match_val._field0.subst))(applySubst(composeSubst(__match_val._field0)(__match_val._field0.subst))(elemType))(__match_val[1:]) if isinstance(__match_val, Just) else (Err(typeError('List elements must have same type')) if __match_val is Nothing else Err(__match_val._field0))))(unify(applySubst(__match_val._field0.subst)(elemType))(applySubst(__match_val._field0.subst)(__match_val._field0.typ))))(inferExpr(state)(subst)(__match_val[0]))))(elements)

def inferTuple(state): return lambda subst: lambda elements: inferTupleElements(state)(subst)([])(elements)

def inferTupleElements(state): return lambda subst: lambda types: lambda elements: (lambda __match_val: (Ok(inferResult(tTuple(List.reverse(types)))(subst)(state)) if __match_val == [] else (lambda __match_val: (inferTupleElements(__match_val._field0.state)(__match_val._field0.subst)([applySubst(__match_val._field0.subst)(__match_val._field0.typ)] + types)(__match_val[1:]) if isinstance(__match_val, Ok) else Err(__match_val._field0)))(inferExpr(state)(subst)(__match_val[0]))))(elements)

def inferMatch(state): return lambda subst: lambda scrutinee: lambda cases: (lambda __match_val: ((lambda __let_val_9: Ok(inferResult(__let_val_9[0])(__match_val._field0.subst)(__let_val_9[1])) if isinstance(__let_val_9, tuple) and len(__let_val_9) == 2 else None)(freshVar(__match_val._field0.state)) if List.isEmpty(cases) else (lambda __let_val_10: inferMatchCases(__let_val_10[1])(__match_val._field0.subst)(__match_val._field0.typ)(__let_val_10[0])(cases) if isinstance(__let_val_10, tuple) and len(__let_val_10) == 2 else None)(freshVar(__match_val._field0.state)) if isinstance(__match_val, Ok) else Err(__match_val._field0)))(inferExpr(state)(subst)(scrutinee))

def inferMatchCases(state): return lambda subst: lambda scrutineeType: lambda resultType: lambda cases: (lambda __match_val: (Ok(inferResult(applySubst(subst)(resultType))(subst)(state)) if __match_val == [] else (lambda __match_val: (lambda __match_val: (lambda composed: (lambda envWithPattern: (lambda __match_val: (lambda __match_val: (inferMatchCases(__match_val._field0.state)(composeSubst(__match_val._field0)(__match_val._field0.subst))(applySubst(composeSubst(__match_val._field0)(__match_val._field0.subst))(scrutineeType))(applySubst(composeSubst(__match_val._field0)(__match_val._field0.subst))(resultType))(__match_val[1:]) if isinstance(__match_val, Just) else (Err(typeError('Match cases must have same type')) if __match_val is Nothing else (Err(__match_val._field0) if isinstance(__match_val, Err) else (Err(typeError('Pattern type mismatch')) if __match_val is Nothing else Err(__match_val._field0))))))(unify(applySubst(__match_val._field0.subst)(resultType))(__match_val._field0.typ)))(inferExpr(Record({**state, "env": envWithPattern}))(composed)(__match_val[0].body)))(mergeEnv(state.env)(__match_val._field0[1])))(composeSubst(__match_val._field0)(__match_val._field0[2])))(unify(applySubst(__match_val._field0[2])(scrutineeType))(applySubst(__match_val._field0[2])(__match_val._field0[0]))))(inferPattern(state)(subst)(__match_val[0].pattern))))(cases)

def inferPattern(state): return lambda subst: lambda pattern: (lambda __match_val: (Ok((TInt, emptyEnv, subst)) if isinstance(__match_val, IntPattern) else (Ok((TFloat, emptyEnv, subst)) if isinstance(__match_val, FloatPattern) else (Ok((TString, emptyEnv, subst)) if isinstance(__match_val, StringPattern) else (Ok((TChar, emptyEnv, subst)) if isinstance(__match_val, CharPattern) else (Ok((TBool, emptyEnv, subst)) if isinstance(__match_val, BoolPattern) else ((lambda __let_val_11: Ok((__let_val_11[0], extendEnv(emptyEnv)(__match_val._field0)(monoScheme(__let_val_11[0])), subst)) if isinstance(__let_val_11, tuple) and len(__let_val_11) == 2 else None)(freshVar(state)) if isinstance(__match_val, VarPattern) else ((lambda __let_val_12: Ok((__let_val_12[0], emptyEnv, subst)) if isinstance(__let_val_12, tuple) and len(__let_val_12) == 2 else None)(freshVar(state)) if __match_val is WildcardPattern else (inferListPattern(state)(subst)(__match_val._field0) if isinstance(__match_val, ListPattern) else (inferConsPattern(state)(subst)(__match_val._field0.head)(__match_val._field0.tail) if isinstance(__match_val, ConsPattern) else (inferTuplePattern(state)(subst)(__match_val._field0) if isinstance(__match_val, TuplePattern) else (lambda __let_val_13: Ok((__let_val_13[0], emptyEnv, subst)) if isinstance(__let_val_13, tuple) and len(__let_val_13) == 2 else None)(freshVar(state)))))))))))))(pattern)

def inferListPattern(state): return lambda subst: lambda elements: (lambda __match_val: ((lambda __let_val_14: Ok((tList(__let_val_14[0]), emptyEnv, subst)) if isinstance(__let_val_14, tuple) and len(__let_val_14) == 2 else None)(freshVar(state)) if __match_val == [] else (lambda __match_val: (lambda __match_val: (Ok((tList(__match_val._field0[0]), __match_val._field0[1], __match_val._field0[2])) if isinstance(__match_val, Ok) and isinstance(__match_val._field0, tuple) and len(__match_val._field0) == 3 else (Err(__match_val._field0) if isinstance(__match_val, Err) else Err(__match_val._field0))))(inferListPatternElements(state)(__match_val._field0[2])(__match_val._field0[0])(__match_val._field0[1])(__match_val[1:])))(inferPattern(state)(subst)(__match_val[0]))))(elements)

def inferListPatternElements(state): return lambda subst: lambda elemType: lambda env: lambda elements: (lambda __match_val: (Ok((elemType, env, subst)) if __match_val == [] else (lambda __match_val: (lambda __match_val: (inferListPatternElements(state)(composeSubst(__match_val._field0)(__match_val._field0[2]))(applySubst(composeSubst(__match_val._field0)(__match_val._field0[2]))(elemType))(mergeEnv(env)(__match_val._field0[1]))(__match_val[1:]) if isinstance(__match_val, Just) else (Err(typeError('Pattern elements must have same type')) if __match_val is Nothing else Err(__match_val._field0))))(unify(applySubst(__match_val._field0[2])(elemType))(applySubst(__match_val._field0[2])(__match_val._field0[0]))))(inferPattern(state)(subst)(__match_val[0]))))(elements)

def inferConsPattern(state): return lambda subst: lambda head: lambda tail: (lambda __match_val: (lambda __match_val: (lambda __match_val: (Ok((tList(applySubst(composeSubst(__match_val._field0)(__match_val._field0[2]))(__match_val._field0[0])), mergeEnv(__match_val._field0[1])(__match_val._field0[1]), composeSubst(__match_val._field0)(__match_val._field0[2]))) if isinstance(__match_val, Just) else (Err(typeError('Cons pattern type mismatch')) if __match_val is Nothing else (Err(__match_val._field0) if isinstance(__match_val, Err) else Err(__match_val._field0)))))(unify(applySubst(__match_val._field0[2])(__match_val._field0[0]))(tList(applySubst(__match_val._field0[2])(__match_val._field0[0])))))(inferPattern(state)(__match_val._field0[2])(tail)))(inferPattern(state)(subst)(head))

def inferTuplePattern(state): return lambda subst: lambda elements: inferTuplePatternElements(state)(subst)([])(emptyEnv)(elements)

def inferTuplePatternElements(state): return lambda subst: lambda types: lambda env: lambda elements: (lambda __match_val: (Ok((tTuple(List.reverse(types)), env, subst)) if __match_val == [] else (lambda __match_val: (inferTuplePatternElements(state)(__match_val._field0[2])([applySubst(__match_val._field0[2])(__match_val._field0[0])] + types)(mergeEnv(env)(__match_val._field0[1]))(__match_val[1:]) if isinstance(__match_val, Ok) and isinstance(__match_val._field0, tuple) and len(__match_val._field0) == 3 else Err(__match_val._field0)))(inferPattern(state)(subst)(__match_val[0]))))(elements)

def inferIndexAccess(state): return lambda subst: lambda expr: lambda index: (lambda __match_val: (lambda __match_val: (lambda __match_val: ((lambda __let_val_15: Ok(inferResult(__let_val_15[0])(composeSubst(__match_val._field0)(__match_val._field0.subst))(__let_val_15[1])) if isinstance(__let_val_15, tuple) and len(__let_val_15) == 2 else None)(freshVar(__match_val._field0.state)) if isinstance(__match_val, Just) else (Err(typeError('Index must be Int')) if __match_val is Nothing else (Err(__match_val._field0) if isinstance(__match_val, Err) else Err(__match_val._field0)))))(unify(applySubst(__match_val._field0.subst)(__match_val._field0.typ))(TInt)))(inferExpr(__match_val._field0.state)(__match_val._field0.subst)(index)))(inferExpr(state)(subst)(expr))

def mergeEnv(e1): return lambda e2: Record({"bindings": Dict.merge(e1.bindings)(e2.bindings)})
