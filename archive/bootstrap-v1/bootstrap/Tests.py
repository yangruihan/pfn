# ============================================================

# AUTO-GENERATED CODE - DO NOT EDIT

# Generated by Pfn compiler

# Generated at: 2026-02-28 21:52:37

# ============================================================



from __future__ import annotations

from stdlib import String, List, Dict, Set, Maybe, Result, Just, Nothing, Ok, Err, Record

from stdlib import reverse, _not_

from bootstrap.Token import *

from bootstrap.Lexer import *

from bootstrap.AST import *

from bootstrap.Parser import *

from bootstrap.Types import *

from bootstrap.TypeChecker import *

from bootstrap.Codegen import *

from dataclasses import dataclass

@dataclass
class TestResult:
    name: str
    passed: bool
    message: str

def testResult(name):
    return lambda passed: lambda message: Record({"name": name, "passed": passed, "message": message})

def _pass_(name):
    return testResult(name)(True)('OK')

def fail(name):
    return lambda message: testResult(name)(False)(message)

testKeywords = ((__helper_0(kw)) if (kw := (lookupKeyword('def'))) is not None else None)

testTokenCreation = ((((_pass_('token creation') if tok.tokenType == IDENT and getTokenString(tok) == 'foo' else fail('token creation')('Token not created correctly')) if (tok := (stringToken(IDENT)('foo')(span))) is not None else None)) if (span := (makeSpan(0)(3)(1)(1))) is not None else None)

testLexerSimple = ((__helper_2(tokens)) if (tokens := (tokenize('def foo = 42'))) is not None else None)

testLexerString = ((__helper_4(tokens)) if (tokens := (tokenize('"hello world"'))) is not None else None)

testLexerOperators = ((__helper_5(tokens)) if (tokens := (tokenize('-> => :: ++ ||'))) is not None else None)

testParseInt = ((__helper_7(tokens)) if (tokens := (tokenize('42'))) is not None else None)

testParseDef = ((__helper_10(tokens)) if (tokens := (tokenize('def add x y = x + y'))) is not None else None)

testParseLambda = ((__helper_13(tokens)) if (tokens := (tokenize('fn x => x + 1'))) is not None else None)

testParseList = ((__helper_16(tokens)) if (tokens := (tokenize('[1, 2, 3]'))) is not None else None)

testUnifyInt = __helper_17(unify(TInt)(TInt))

testUnifyVar = ((__helper_19(unify(tv)(TInt))) if (tv := (tVar('a'))) is not None else None)

testUnifyFun = ((((__helper_21(unify(t1)(t2))) if (t2 := (tFun(TInt)(TString))) is not None else None)) if (t1 := (tFun(TInt)(tVar('a')))) is not None else None)

testFreeVars = ((((_pass_('free vars') if Set.member('a')(fv) and Set.member('b')(fv) else fail('free vars')('Should have a and b as free vars')) if (fv := (freeVars(t))) is not None else None)) if (t := (tFun(tVar('a'))(tVar('b')))) is not None else None)

testInferInt = ((__helper_23(infer(state)(IntLit(42)))) if (state := (initTypeChecker)) is not None else None)

testInferString = ((__helper_25(infer(state)(StringLit('hello')))) if (state := (initTypeChecker)) is not None else None)

testInferLambda = ((((__helper_27(infer(state)(expr))) if (expr := (Lambda(Record({"params": [param('x')], "body": Var('x')})))) is not None else None)) if (state := (initTypeChecker)) is not None else None)

testInferList = ((((__helper_30(infer(state)(expr))) if (expr := (ListLit([IntLit(1), IntLit(2), IntLit(3)]))) is not None else None)) if (state := (initTypeChecker)) is not None else None)

testCodegenInt = ((_pass_('codegen int') if code == '42' else fail('codegen int')("Expected '42', got: " + code)) if (code := (generateExpr(IntLit(42)))) is not None else None)

testCodegenString = ((_pass_('codegen string') if code == '"hello"' else fail('codegen string')('Expected \'"hello"\', got: ' + code)) if (code := (generateExpr(StringLit('hello')))) is not None else None)

testCodegenLambda = ((((_pass_('codegen lambda') if code == 'lambda x: x' else fail('codegen lambda')("Expected 'lambda x: x', got: " + code)) if (code := (generateExpr(expr))) is not None else None)) if (expr := (Lambda(Record({"params": [param('x')], "body": Var('x')})))) is not None else None)

testCodegenList = ((((_pass_('codegen list') if code == '[1, 2, 3]' else fail('codegen list')("Expected '[1, 2, 3]', got: " + code)) if (code := (generateExpr(expr))) is not None else None)) if (expr := (ListLit([IntLit(1), IntLit(2), IntLit(3)]))) is not None else None)

testCodegenBinOp = ((((_pass_('codegen binop') if code == '1 + 2' else fail('codegen binop')("Expected '1 + 2', got: " + code)) if (code := (generateExpr(expr))) is not None else None)) if (expr := (BinOp(Record({"left": IntLit(1), "op": '+', "right": IntLit(2)})))) is not None else None)

testCodegenIf = ((((_pass_('codegen if') if code == '1 if x else 0' else fail('codegen if')("Expected '1 if x else 0', got: " + code)) if (code := (generateExpr(expr))) is not None else None)) if (expr := (If(Record({"cond": Var('x'), "thenBranch": IntLit(1), "elseBranch": IntLit(0)})))) is not None else None)

runTests = [testKeywords, testTokenCreation, testLexerSimple, testLexerString, testLexerOperators, testParseInt, testParseDef, testParseLambda, testParseList, testUnifyInt, testUnifyVar, testUnifyFun, testFreeVars, testInferInt, testInferString, testInferLambda, testInferList, testCodegenInt, testCodegenString, testCodegenLambda, testCodegenList, testCodegenBinOp, testCodegenIf]

def countPassed(results):
    return List.foldl(lambda acc: lambda r: acc + 1 if r.passed else acc)(0)(results)

def printResults(results):
    return ((((((((header + details) if (details := (String.join('\n')(List.map(formatResult)(results)))) is not None else None)) if (header := ('Bootstrap Tests: ' + toString(passed) + '/' + toString(total) + ' passed\n')) is not None else None)) if (total := (List.length(results))) is not None else None)) if (passed := (countPassed(results))) is not None else None)

def formatResult(r):
    return '  ✓ ' + r.name if r.passed else '  ✗ ' + r.name + ': ' + r.message

main = printResults(runTests)


# Helper functions to avoid deep nesting
def __helper_0(__match_val):
    return ((_pass_('keywords lookup') if isinstance(__match_val, Just) and __match_val._field0 is KW_DEF else None)) or (fail('keywords lookup')("Expected KW_DEF for 'def'"))
def __helper_1(__match_val):
    return ((_pass_('lexer simple') if __match_val._field0.tokenType == KW_DEF else fail('lexer simple')('First token should be KW_DEF') if isinstance(__match_val, Just) else None)) or ((fail('lexer simple')('No tokens') if __match_val is Nothing else None))
def __helper_2(__match_val):
    return ((__helper_1(List.getAt(0)(__match_val._field0)) if List.length(__match_val._field0) >= 4 else fail('lexer simple')('Expected at least 4 tokens') if isinstance(__match_val, Ok) else None)) or ((fail('lexer simple')('Lexer error') if isinstance(__match_val, Err) else None))
def __helper_3(__match_val):
    return ((_pass_('lexer string') if __match_val._field0.tokenType == STRING and getTokenString(__match_val._field0) == 'hello world' else fail('lexer string')('String not lexed correctly') if isinstance(__match_val, Just) else None)) or ((fail('lexer string')('No tokens') if __match_val is Nothing else None)) or ((fail('lexer string')('Lexer error') if isinstance(__match_val, Err) else None))
def __helper_4(__match_val):
    return (__helper_3(List.getAt(0)(__match_val._field0)) if isinstance(__match_val, Ok) else None)
def __helper_5(__match_val):
    return ((_pass_('lexer operators') if List.length(__match_val._field0) >= 5 else fail('lexer operators')('Not enough operator tokens') if isinstance(__match_val, Ok) else None)) or ((fail('lexer operators')('Lexer error') if isinstance(__match_val, Err) else None))
def __helper_6(__match_val):
    return ((_pass_('parse int - empty module') if List.isEmpty(__match_val._field0.declarations) else fail('parse int')('Expected empty module for lone int') if isinstance(__match_val, Ok) else None)) or ((fail('parse int')(errorToString(__match_val._field0)) if isinstance(__match_val, Err) else None)) or ((fail('parse int')('Lexer error') if isinstance(__match_val, Err) else None))
def __helper_7(__match_val):
    return (__helper_6(parse(__match_val._field0)) if isinstance(__match_val, Ok) else None)
def __helper_8(__match_val):
    return ((_pass_('parse def') if __match_val._field0._field0.name == 'add' and List.length(__match_val._field0._field0.params) == 2 else fail('parse def')('Function not parsed correctly') if isinstance(__match_val, Just) and isinstance(__match_val._field0, DefDecl) else None)) or (fail('parse def')('Expected DefDecl')) or ((fail('parse def')(errorToString(__match_val._field0)) if isinstance(__match_val, Err) else None)) or ((fail('parse def')('Lexer error') if isinstance(__match_val, Err) else None))
def __helper_9(__match_val):
    return (fail('parse def')('Expected one declaration') if List.isEmpty(__match_val._field0.declarations) else __helper_8(List.getAt(0)(__match_val._field0.declarations)) if isinstance(__match_val, Ok) else None)
def __helper_10(__match_val):
    return (__helper_9(parse(__match_val._field0)) if isinstance(__match_val, Ok) else None)
def __helper_11(__match_val):
    return ((_pass_('parse lambda') if List.length(__match_val._field0.params) == 1 else fail('parse lambda')('Lambda params incorrect') if isinstance(__match_val, Lambda) else None)) or (fail('parse lambda')('Expected Lambda')) or ((fail('parse lambda')(errorToString(__match_val._field0)) if isinstance(__match_val, Err) else None)) or ((fail('parse lambda')('Lexer error') if isinstance(__match_val, Err) else None))
def __helper_12(__match_val):
    return (__helper_11(__match_val._field0[0]) if isinstance(__match_val, Ok) and isinstance(__match_val._field0, tuple) and len(__match_val._field0) == 2 else None)
def __helper_13(__match_val):
    return (__helper_12(parseExpr(initParser(__match_val._field0))) if isinstance(__match_val, Ok) else None)
def __helper_14(__match_val):
    return ((_pass_('parse list') if List.length(__match_val._field0) == 3 else fail('parse list')('List length incorrect') if isinstance(__match_val, ListLit) else None)) or (fail('parse list')('Expected ListLit')) or ((fail('parse list')(errorToString(__match_val._field0)) if isinstance(__match_val, Err) else None)) or ((fail('parse list')('Lexer error') if isinstance(__match_val, Err) else None))
def __helper_15(__match_val):
    return (__helper_14(__match_val._field0[0]) if isinstance(__match_val, Ok) and isinstance(__match_val._field0, tuple) and len(__match_val._field0) == 2 else None)
def __helper_16(__match_val):
    return (__helper_15(parseExpr(initParser(__match_val._field0))) if isinstance(__match_val, Ok) else None)
def __helper_17(__match_val):
    return ((_pass_('unify int') if isinstance(__match_val, Just) else None)) or ((fail('unify int')('Int should unify with Int') if __match_val is Nothing else None))
def __helper_18(__match_val):
    return ((_pass_('unify var') if __match_val is TInt else None)) or (fail('unify var')('Variable should be substituted to Int')) or ((fail('unify var')('Var should unify with Int') if __match_val is Nothing else None))
def __helper_19(__match_val):
    return (((__helper_18(result)) if (result := (applySubst(__match_val._field0)(tv))) is not None else None) if isinstance(__match_val, Just) else None)
def __helper_20(__match_val):
    return ((_pass_('unify fun') if __match_val is TString else None)) or (fail('unify fun')('Type variable should be String')) or ((fail('unify fun')('Functions should unify') if __match_val is Nothing else None))
def __helper_21(__match_val):
    return (((__helper_20(result)) if (result := (applySubst(__match_val._field0)(tVar('a')))) is not None else None) if isinstance(__match_val, Just) else None)
def __helper_22(__match_val):
    return ((_pass_('infer int') if __match_val is TInt else None)) or (fail('infer int')('Expected Int type')) or ((fail('infer int')(__match_val._field0.message) if isinstance(__match_val, Err) else None))
def __helper_23(__match_val):
    return (__helper_22(__match_val._field0.type) if isinstance(__match_val, Ok) else None)
def __helper_24(__match_val):
    return ((_pass_('infer string') if __match_val is TString else None)) or (fail('infer string')('Expected String type')) or ((fail('infer string')(__match_val._field0.message) if isinstance(__match_val, Err) else None))
def __helper_25(__match_val):
    return (__helper_24(__match_val._field0.type) if isinstance(__match_val, Ok) else None)
def __helper_26(__match_val):
    return ((_pass_('infer lambda') if isinstance(__match_val, TFun) else None)) or (fail('infer lambda')('Expected function type')) or ((fail('infer lambda')(__match_val._field0.message) if isinstance(__match_val, Err) else None))
def __helper_27(__match_val):
    return (__helper_26(__match_val._field0.type) if isinstance(__match_val, Ok) else None)
def __helper_28(__match_val):
    return ((_pass_('infer list') if __match_val is TInt else None)) or (fail('infer list')('Expected Int element type')) or (fail('infer list')('Expected List type')) or ((fail('infer list')(__match_val._field0.message) if isinstance(__match_val, Err) else None))
def __helper_29(__match_val):
    return (__helper_28(__match_val._field0.elem) if isinstance(__match_val, TList) else None)
def __helper_30(__match_val):
    return (__helper_29(__match_val._field0.type) if isinstance(__match_val, Ok) else None)