# ============================================================

# AUTO-GENERATED CODE - DO NOT EDIT

# Generated by Pfn compiler

# Generated at: 2026-02-28 21:52:37

# ============================================================



from __future__ import annotations

from stdlib import String, List, Dict, Set, Maybe, Result, Just, Nothing, Ok, Err, Record

from stdlib import reverse, _not_

from dataclasses import dataclass
from typing import Union

class TInt:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class TFloat:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class TString:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class TBool:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class TChar:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class TUnit:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

@dataclass
class TVar:
    _field0: TVarData

@dataclass
class TFun:
    _field0: TFunData

@dataclass
class TList:
    _field0: TListData

@dataclass
class TTuple:
    _field0: TTupleData

@dataclass
class TCon:
    _field0: TConData

Type = Union[TInt, TFloat, TString, TBool, TChar, TUnit, TVar, TFun, TList, TTuple, TCon]
TInt = TInt()
TFloat = TFloat()
TString = TString()
TBool = TBool()
TChar = TChar()
TUnit = TUnit()

from dataclasses import dataclass

@dataclass
class TVarData:
    name: str

from dataclasses import dataclass

@dataclass
class TFunData:
    param: Type
    result: Type

from dataclasses import dataclass

@dataclass
class TListData:
    elem: Type

from dataclasses import dataclass

@dataclass
class TTupleData:
    elements: list[Type]

from dataclasses import dataclass

@dataclass
class TConData:
    name: str
    args: list[Type]

from dataclasses import dataclass

@dataclass
class Scheme:
    vars: list[str]
    typ: Type

from dataclasses import dataclass

@dataclass
class TypeEnv:
    bindings: Dict[str, Scheme]

emptyEnv = Record({"bindings": Dict.empty()})

def extendEnv(env):
    return lambda name: lambda scheme: Record({"bindings": Dict.insert(name)(scheme)(env.bindings)})

def lookupEnv(env):
    return lambda name: Dict.lookup(name)(env.bindings)

from dataclasses import dataclass

@dataclass
class Subst:
    mapping: Dict[str, Type]

emptySubst = Record({"mapping": Dict.empty()})

def singletonSubst(name):
    return lambda t: Record({"mapping": Dict.singleton(name)(t)})

def applySubst(subst):
    return lambda t: __helper_1(t)

def composeSubst(s1):
    return lambda s2: ((Record({"mapping": Dict.merge(s1.mapping)(applied)})) if (applied := (Dict.map(lambda _: lambda v: applySubst(s1)(v))(s2.mapping))) is not None else None)

def freeVars(t):
    return __helper_2(t)

def freeVarsScheme(scheme):
    return Set.difference(freeVars(scheme.type))(Set.fromList(scheme.vars))

def freeVarsEnv(env):
    return Dict.foldl(lambda acc: lambda _: lambda scheme: Set.union(acc)(freeVarsScheme(scheme)))(Set.empty())(env.bindings)

def occursIn(name):
    return lambda t: Set.member(name)(freeVars(t))

def unify(t1):
    return lambda t2: __helper_5((t1, t2))

def unifyList(ts1):
    return lambda ts2: lambda subst: __helper_7((ts1, ts2))

def tVar(name):
    return TVar(Record({"name": name}))

def tFun(param):
    return lambda result: TFun(Record({"param": param, "result": result}))

def tList(elem):
    return TList(Record({"elem": elem}))

def tTuple(elements):
    return TTuple(Record({"elements": elements}))

def tCon(name):
    return lambda args: TCon(Record({"name": name, "args": args}))

def monoScheme(t):
    return Record({"vars": [], "typ": t})

def polyScheme(vars):
    return lambda t: Record({"vars": vars, "typ": t})

def typeToString(t):
    return __helper_9(t)


# Helper functions to avoid deep nesting
def __helper_0(__match_val):
    return ((applySubst(subst)(__match_val._field0) if isinstance(__match_val, Just) else None)) or ((t if __match_val is Nothing else None)) or ((TFun(Record({"param": applySubst(subst)(__match_val._field0.param), "result": applySubst(subst)(__match_val._field0.result)})) if isinstance(__match_val, TFun) else None)) or ((TList(Record({"elem": applySubst(subst)(__match_val._field0.elem)})) if isinstance(__match_val, TList) else None)) or ((TTuple(Record({"elements": List.map(lambda x: applySubst(subst)(x))(__match_val._field0.elements)})) if isinstance(__match_val, TTuple) else None)) or ((TCon(Record({"name": __match_val._field0.name, "args": List.map(lambda x: applySubst(subst)(x))(__match_val._field0.args)})) if isinstance(__match_val, TCon) else None))
def __helper_1(__match_val):
    return ((TInt if __match_val is TInt else None)) or ((TFloat if __match_val is TFloat else None)) or ((TString if __match_val is TString else None)) or ((TBool if __match_val is TBool else None)) or ((TChar if __match_val is TChar else None)) or ((TUnit if __match_val is TUnit else None)) or ((__helper_0(Dict.lookup(__match_val._field0.name)(subst.mapping)) if isinstance(__match_val, TVar) else None))
def __helper_2(__match_val):
    return ((Set.empty() if __match_val is TInt else None)) or ((Set.empty() if __match_val is TFloat else None)) or ((Set.empty() if __match_val is TString else None)) or ((Set.empty() if __match_val is TBool else None)) or ((Set.empty() if __match_val is TChar else None)) or ((Set.empty() if __match_val is TUnit else None)) or ((Set.singleton(__match_val._field0.name) if isinstance(__match_val, TVar) else None)) or ((Set.union(freeVars(__match_val._field0.param))(freeVars(__match_val._field0.result)) if isinstance(__match_val, TFun) else None)) or ((freeVars(__match_val._field0.elem) if isinstance(__match_val, TList) else None)) or ((List.foldl(lambda acc: lambda x: Set.union(acc)(freeVars(x)))(Set.empty())(__match_val._field0.elements) if isinstance(__match_val, TTuple) else None)) or ((List.foldl(lambda acc: lambda x: Set.union(acc)(freeVars(x)))(Set.empty())(__match_val._field0.args) if isinstance(__match_val, TCon) else None))
def __helper_3(__match_val):
    return ((Just(composeSubst(__match_val._field0)(s1)) if isinstance(__match_val, Just) else None)) or ((Nothing if __match_val is Nothing else None)) or ((Nothing if __match_val is Nothing else None)) or ((unify(__match_val[0]._field0.elem)(__match_val[1]._field0.elem) if isinstance(__match_val, tuple) and len(__match_val) == 2 and isinstance(__match_val[0], TList) and isinstance(__match_val[1], TList) else None)) or ((unifyList(__match_val[0]._field0.elements)(__match_val[1]._field0.elements)(emptySubst) if List.length(__match_val[0]._field0.elements) == List.length(__match_val[1]._field0.elements) else Nothing if isinstance(__match_val, tuple) and len(__match_val) == 2 and isinstance(__match_val[0], TTuple) and isinstance(__match_val[1], TTuple) else None)) or (Nothing)
def __helper_4(__match_val):
    return (((((__helper_3(unify(t1Result)(t2Result))) if (t2Result := (applySubst(__match_val._field0)(d2.result))) is not None else None)) if (t1Result := (applySubst(__match_val._field0)(d1.result))) is not None else None) if isinstance(__match_val, Just) else None)
def __helper_5(__match_val):
    return ((Just(emptySubst) if isinstance(__match_val, tuple) and len(__match_val) == 2 and __match_val[0] is TInt and __match_val[1] is TInt else None)) or ((Just(emptySubst) if isinstance(__match_val, tuple) and len(__match_val) == 2 and __match_val[0] is TFloat and __match_val[1] is TFloat else None)) or ((Just(emptySubst) if isinstance(__match_val, tuple) and len(__match_val) == 2 and __match_val[0] is TString and __match_val[1] is TString else None)) or ((Just(emptySubst) if isinstance(__match_val, tuple) and len(__match_val) == 2 and __match_val[0] is TBool and __match_val[1] is TBool else None)) or ((Just(emptySubst) if isinstance(__match_val, tuple) and len(__match_val) == 2 and __match_val[0] is TChar and __match_val[1] is TChar else None)) or ((Just(emptySubst) if isinstance(__match_val, tuple) and len(__match_val) == 2 and __match_val[0] is TUnit and __match_val[1] is TUnit else None)) or ((Just(emptySubst) if __match_val[0]._field0.name == __match_val[1]._field0.name else Just(singletonSubst(__match_val[0]._field0.name)(t2)) if isinstance(__match_val, tuple) and len(__match_val) == 2 and isinstance(__match_val[0], TVar) and isinstance(__match_val[1], TVar) else None)) or ((Nothing if occursIn(__match_val[0]._field0.name)(t2) else Just(singletonSubst(__match_val[0]._field0.name)(t2)) if isinstance(__match_val, tuple) and len(__match_val) == 2 and isinstance(__match_val[0], TVar) else None)) or ((Nothing if occursIn(__match_val[1]._field0.name)(t1) else Just(singletonSubst(__match_val[1]._field0.name)(t1)) if isinstance(__match_val, tuple) and len(__match_val) == 2 and isinstance(__match_val[1], TVar) else None)) or ((__helper_4(unify(__match_val[0]._field0.param)(__match_val[1]._field0.param)) if isinstance(__match_val, tuple) and len(__match_val) == 2 and isinstance(__match_val[0], TFun) and isinstance(__match_val[1], TFun) else None))
def __helper_6(__match_val):
    return ((unifyList(rest1)(rest2)(composeSubst(__match_val._field0)(subst)) if isinstance(__match_val, Just) else None)) or ((Nothing if __match_val is Nothing else None)) or (Nothing)
def __helper_7(__match_val):
    return ((Just(subst) if isinstance(__match_val, tuple) and len(__match_val) == 2 and __match_val[0] == [] and __match_val[1] == [] else None)) or ((__helper_6(unify(applySubst(subst)(__match_val[0][0]))(applySubst(subst)(__match_val[1][0]))) if isinstance(__match_val, tuple) and len(__match_val) == 2 and isinstance(__match_val[0], list) and len(__match_val[0]) > 0 and isinstance(__match_val[1], list) and len(__match_val[1]) > 0 else None))
def __helper_8(__match_val):
    return (('(' + typeToString(d.param) + ')' if isinstance(__match_val, TFun) else None)) or (typeToString(d.param))
def __helper_9(__match_val):
    return (('Int' if __match_val is TInt else None)) or (('Float' if __match_val is TFloat else None)) or (('String' if __match_val is TString else None)) or (('Bool' if __match_val is TBool else None)) or (('Char' if __match_val is TChar else None)) or (('()' if __match_val is TUnit else None)) or ((__match_val._field0.name if isinstance(__match_val, TVar) else None)) or ((((paramStr + ' -> ' + typeToString(__match_val._field0.result)) if (paramStr := (__helper_8(__match_val._field0.param))) is not None else None) if isinstance(__match_val, TFun) else None)) or (('[' + typeToString(__match_val._field0.elem) + ']' if isinstance(__match_val, TList) else None)) or (((('(' + elems + ')') if (elems := (String.join(', ')(List.map(typeToString)(__match_val._field0.elements)))) is not None else None) if isinstance(__match_val, TTuple) else None)) or ((__match_val._field0.name if List.isEmpty(__match_val._field0.args) else __match_val._field0.name + ' ' + String.join(' ')(List.map(typeToString)(__match_val._field0.args)) if isinstance(__match_val, TCon) else None))