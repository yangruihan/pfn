# ============================================================

# AUTO-GENERATED CODE - DO NOT EDIT

# Generated by Pfn compiler

# Generated at: 2026-02-28 21:52:37

# ============================================================



from __future__ import annotations

from stdlib import String, List, Dict, Set, Maybe, Result, Just, Nothing, Ok, Err, Record

from stdlib import reverse, _not_

from bootstrap.AST import *

def generateModule(mod):
    return ((((header + body) if (body := (generateDecls(mod.declarations)([]))) is not None else None)) if (header := (generateAutogenHeader())) is not None else None)

generateAutogenHeader = '# ============================================================\n' + '# AUTO-GENERATED CODE - DO NOT EDIT\n' + '# Generated by Pfn Bootstrap Compiler\n' + '# ============================================================\n\n' + 'from __future__ import annotations\n\n' + 'from stdlib import String, List, Dict, Set, Maybe, Result, Just, Nothing, Ok, Err, Record\n\n' + 'from stdlib import reverse, _not_\n'

def generateDecls(decls):
    return lambda lines: __helper_0(decls)

def generateDecl(decl):
    return __helper_1(decl)

def generateDefDecl(decl):
    return ((((((((funcDef + '\n\n' + exportName + ' = ' + decl.name) if (exportName := (__helper_2(decl.exportName))) is not None else None) if decl.isExported else funcDef) if (funcDef := (generateFuncDef(decl.name)(decl.params)(bodyCode))) is not None else None)) if (bodyCode := (generateExpr(decl.body))) is not None else None)) if (paramsStr := (generateParams(decl.params))) is not None else None)

def generateParams(params):
    return String.join(', ')(List.map(lambda p: p.name)(params))

def generateFuncDef(name):
    return lambda params: lambda bodyCode: (('def ' + name + '():\n    return ' + bodyCode if paramsStr == '' else 'def ' + name + '(' + paramsStr + '):\n    return ' + bodyCode) if (paramsStr := (generateParams(params))) is not None else None)

def generateCurriedBody(params):
    return lambda body: __helper_3(params)

def generateTypeDecl(decl):
    return generateRecordType(decl) if decl.isRecord else generateSumType(decl)

def generateRecordType(decl):
    return ((((header + '\n' + String.join('\n')(fields)) if (fields := (generateRecordFields(decl.recordFields)([]))) is not None else None)) if (header := ('from dataclasses import dataclass\n\n@dataclass\nclass ' + decl.name + ':')) is not None else None)

def generateRecordFields(fields):
    return lambda lines: __helper_4(fields)

def generateSumType(decl):
    return ((((((((header + String.join('\n')(ctors) + unionDef) if (unionDef := ('\n' + decl.name + ' = Union[' + String.join(', ')(ctorNames) + ']')) is not None else None)) if (ctorNames := (List.map(lambda c: c.name)(decl.constructors))) is not None else None)) if (ctors := (generateConstructors(decl.constructors)([]))) is not None else None)) if (header := ('from dataclasses import dataclass\nfrom typing import Union\n')) is not None else None)

def generateConstructors(ctors):
    return lambda lines: __helper_5(ctors)

def generateConstructor(ctor):
    return '@dataclass\nclass ' + ctor.name + ':\n    pass\n' if List.isEmpty(ctor.fields) else (('@dataclass\nclass ' + ctor.name + ':\n' + String.join('\n')(fields) + '\n') if (fields := (generateCtorFields(ctor.fields)(0)([]))) is not None else None)

def generateCtorFields(fields):
    return lambda index: lambda lines: __helper_6(fields)

def generateImportDecl(decl):
    return __helper_7(decl.alias)

def generateTypeRef(typeRef):
    return __helper_8(typeRef)

def generateSimpleTypeRef(data):
    return ((name if List.isEmpty(data.args) else ((name + '[' + argsStr + ']') if (argsStr := (String.join(', ')(List.map(generateTypeRef)(data.args)))) is not None else None)) if (name := (mapTypeName(data.name))) is not None else None)

def mapTypeName(name):
    return __helper_9(name)

def generateExpr(expr):
    return __helper_10(expr)

def generateLambda(data):
    return (((('lambda ' + paramsStr + ': ' + bodyCode) if (bodyCode := (generateExpr(data.body))) is not None else None)) if (paramsStr := (String.join(', ')(List.map(lambda p: p.name)(data.params)))) is not None else None)

def generateApp(data):
    return ((((funcCode + '(' + argsStr + ')') if (argsStr := (String.join(', ')(List.map(generateExpr)(data.args)))) is not None else None)) if (funcCode := (generateExpr(data.func))) is not None else None)

def generateBinOp(data):
    return ((((__helper_11(data.op)) if (rightCode := (generateExpr(data.right))) is not None else None)) if (leftCode := (generateExpr(data.left))) is not None else None)

def generateUnaryOp(data):
    return ((data.op + operandCode) if (operandCode := (generateExpr(data.operand))) is not None else None)

def generateIf(data):
    return ((((((thenCode + ' if ' + condCode + ' else ' + elseCode) if (elseCode := (generateExpr(data.elseBranch))) is not None else None)) if (thenCode := (generateExpr(data.thenBranch))) is not None else None)) if (condCode := (generateExpr(data.cond))) is not None else None)

def generateLet(data):
    return (((('(' + bodyCode + ' if (' + data.name + ' := ' + valueCode + ') is not None else None)') if (bodyCode := (generateExpr(data.body))) is not None else None)) if (valueCode := (generateExpr(data.value))) is not None else None)

def generateLetFunc(data):
    return (((((('(lambda ' + paramsStr + ': ' + bodyCode + ')(' + valueCode + ')') if (bodyCode := (generateExpr(data.body))) is not None else None)) if (valueCode := (generateExpr(data.value))) is not None else None)) if (paramsStr := (String.join(', ')(List.map(lambda p: p.name)(data.params)))) is not None else None)

def generateMatch(data):
    return 'None' if List.isEmpty(data.cases) else (((('(lambda __match_val: ' + casesCode + ')(' + scrutineeCode + ')') if (casesCode := (generateMatchCases(data.cases)('__match_val'))) is not None else None)) if (scrutineeCode := (generateExpr(data.scrutinee))) is not None else None)

def generateMatchCases(cases):
    return lambda var: (('None' if List.isEmpty(casesCode) else casesCode([0]) if List.length(casesCode) == 1 else '(' + String.join(' or ')(List.map(lambda c: '(' + c + ')')(casesCode)) + ')') if (casesCode := (generateAllCases(cases)(var)([]))) is not None else None)

def generateAllCases(cases):
    return lambda var: lambda acc: __helper_13(cases)

def generateExprWithBindings(expr):
    return lambda bindings: __helper_14(bindings)

def generatePatternCheck(pattern):
    return lambda var: __helper_17(pattern)

def generateList(elements):
    return (('[' + elemsStr + ']') if (elemsStr := (String.join(', ')(List.map(generateExpr)(elements)))) is not None else None)

def generateTuple(elements):
    return (('(' + elemsStr + ')') if (elemsStr := (String.join(', ')(List.map(generateExpr)(elements)))) is not None else None)

def generateRecord(fields):
    return (('{' + fieldsStr + '}') if (fieldsStr := (String.join(', ')(List.map(generateRecordField)(fields)))) is not None else None)

def generateRecordField(field):
    return '"' + field.name + '": ' + generateExpr(field.value)

def generateFieldAccess(data):
    return ((exprCode + '.' + data.field) if (exprCode := (generateExpr(data.expr))) is not None else None)

def generateIndexAccess(data):
    return ((((exprCode + '[' + indexCode + ']') if (indexCode := (generateExpr(data.index))) is not None else None)) if (exprCode := (generateExpr(data.expr))) is not None else None)

def generateDo(data):
    return ((generateDoBindings(List.reverse(data.bindings))(bodyCode)) if (bodyCode := (generateExpr(data.body))) is not None else None)

def generateDoBindings(bindings):
    return lambda result: __helper_18(bindings)

def reprString(s):
    return '"' + escapeString(s) + '"'

def escapeString(s):
    return s

def reprChar(c):
    return "'" + toString(c) + "'"

def generateTuplePatternBindings(elements):
    return lambda var: lambda index: lambda bindings: __helper_20(elements)

def generateConstructorPatternBindings(args):
    return lambda var: lambda index: lambda bindings: __helper_22(args)


# Helper functions to avoid deep nesting
def __helper_0(__match_val):
    return ((String.join('\n\n')(List.reverse(lines)) if __match_val == [] else None)) or ((((generateDecls(__match_val[1:])(lines) if code == '' else generateDecls(__match_val[1:])([code] + lines)) if (code := (generateDecl(__match_val[0]))) is not None else None) if isinstance(__match_val, list) and len(__match_val) > 0 else None))
def __helper_1(__match_val):
    return ((generateDefDecl(__match_val._field0) if isinstance(__match_val, DefDecl) else None)) or ((generateTypeDecl(__match_val._field0) if isinstance(__match_val, TypeDecl) else None)) or ((generateImportDecl(__match_val._field0) if isinstance(__match_val, ImportDecl) else None)) or ('')
def __helper_2(__match_val):
    return ((__match_val._field0 if isinstance(__match_val, Just) else None)) or ((decl.name if __match_val is Nothing else None))
def __helper_3(__match_val):
    return ((body if __match_val == [] else None)) or ((generateCurriedBody(__match_val[1:])('lambda ' + __match_val[0].name + ': ' + body) if isinstance(__match_val, list) and len(__match_val) > 0 else None))
def __helper_4(__match_val):
    return ((List.reverse(lines) if __match_val == [] else None)) or ((((generateRecordFields(__match_val[1:])(['    ' + __match_val[0][0] + ': ' + typeStr] + lines)) if (typeStr := (generateTypeRef(__match_val[0][1]))) is not None else None) if isinstance(__match_val, list) and len(__match_val) > 0 and isinstance(__match_val[0], tuple) and len(__match_val[0]) == 2 else None))
def __helper_5(__match_val):
    return ((List.reverse(lines) if __match_val == [] else None)) or ((((generateConstructors(__match_val[1:])([ctorCode] + lines)) if (ctorCode := (generateConstructor(__match_val[0]))) is not None else None) if isinstance(__match_val, list) and len(__match_val) > 0 else None))
def __helper_6(__match_val):
    return ((List.reverse(lines) if __match_val == [] else None)) or ((((((generateCtorFields(__match_val[1:])(index + 1)(['    ' + fieldName + ': ' + typeStr] + lines)) if (fieldName := ('_field' + toString(index))) is not None else None)) if (typeStr := (generateTypeRef(__match_val[0]))) is not None else None) if isinstance(__match_val, list) and len(__match_val) > 0 else None))
def __helper_7(__match_val):
    return (('import ' + decl.module + ' as ' + __match_val._field0 if isinstance(__match_val, Just) else None)) or (('import ' + decl.module if __match_val is Nothing else None))
def __helper_8(__match_val):
    return ((generateSimpleTypeRef(__match_val._field0) if isinstance(__match_val, SimpleTypeRef) else None)) or (('Callable[[...], ...]' if isinstance(__match_val, FunTypeRef) else None)) or (((('tuple[' + elems + ']') if (elems := (String.join(', ')(List.map(generateTypeRef)(__match_val._field0.elements)))) is not None else None) if isinstance(__match_val, TupleTypeRef) else None)) or (('dict' if isinstance(__match_val, RecordTypeRef) else None))
def __helper_9(__match_val):
    return (('int' if __match_val == 'Int' else None)) or (('float' if __match_val == 'Float' else None)) or (('str' if __match_val == 'String' else None)) or (('bool' if __match_val == 'Bool' else None)) or (('list' if __match_val == 'List' else None)) or (name)
def __helper_10(__match_val):
    return ((toString(__match_val._field0) if isinstance(__match_val, IntLit) else None)) or ((toString(__match_val._field0) if isinstance(__match_val, FloatLit) else None)) or ((reprString(__match_val._field0) if isinstance(__match_val, StringLit) else None)) or ((reprChar(__match_val._field0) if isinstance(__match_val, CharLit) else None)) or (('True' if __match_val._field0 else 'False' if isinstance(__match_val, BoolLit) else None)) or (('None' if __match_val is UnitLit else None)) or ((__match_val._field0 if isinstance(__match_val, Var) else None)) or ((generateLambda(__match_val._field0) if isinstance(__match_val, Lambda) else None)) or ((generateApp(__match_val._field0) if isinstance(__match_val, App) else None)) or ((generateBinOp(__match_val._field0) if isinstance(__match_val, BinOp) else None)) or ((generateUnaryOp(__match_val._field0) if isinstance(__match_val, UnaryOp) else None)) or ((generateIf(__match_val._field0) if isinstance(__match_val, If) else None)) or ((generateLet(__match_val._field0) if isinstance(__match_val, Let) else None)) or ((generateLetFunc(__match_val._field0) if isinstance(__match_val, LetFunc) else None)) or ((generateMatch(__match_val._field0) if isinstance(__match_val, Match) else None)) or ((generateList(__match_val._field0) if isinstance(__match_val, ListLit) else None)) or ((generateTuple(__match_val._field0) if isinstance(__match_val, TupleLit) else None)) or ((generateRecord(__match_val._field0) if isinstance(__match_val, RecordLit) else None)) or ((generateFieldAccess(__match_val._field0) if isinstance(__match_val, FieldAccess) else None)) or ((generateIndexAccess(__match_val._field0) if isinstance(__match_val, IndexAccess) else None)) or ((generateDo(__match_val._field0) if isinstance(__match_val, DoNotation) else None)) or ('')
def __helper_11(__match_val):
    return (('[' + leftCode + '] + ' + rightCode if __match_val == '::' else None)) or ((leftCode + ' + ' + rightCode if __match_val == '++' else None)) or (leftCode + ' ' + data.op + ' ' + rightCode)
def __helper_12(__let_val_0):
    return (lambda patternCheck, bindings: ((((generateAllCases(rest)(var)([caseCode] + acc)) if (caseCode := (bodyCode if patternCheck == 'True' else '(' + bodyCode + ' if ' + patternCheck + ' else None)')) is not None else None)) if (bodyCode := (generateExprWithBindings(c.body)(bindings))) is not None else None))(__let_val_0[0], __let_val_0[1]) if isinstance(__let_val_0, tuple) and len(__let_val_0) == 2 else None
def __helper_13(__match_val):
    return ((List.reverse(acc) if __match_val == [] else None)) or ((__helper_12(generatePatternCheck(__match_val[0].pattern)(var)) if isinstance(__match_val, list) and len(__match_val) > 0 else None))
def __helper_14(__match_val):
    return ((generateExpr(expr) if __match_val == [] else None)) or ((((String.replace(__match_val[0][0])(__match_val[0][1])(code)) if (code := (generateExprWithBindings(expr)(__match_val[1:]))) is not None else None) if isinstance(__match_val, list) and len(__match_val) > 0 and isinstance(__match_val[0], tuple) and len(__match_val[0]) == 2 else None))
def __helper_15(__let_val_1):
    return (lambda tailCheck, tailBindings: (((((finalCheck2, headBindings + tailBindings)) if (finalCheck2 := (finalCheck if tailCheck == 'True' else finalCheck + ' and ' + tailCheck)) is not None else None)) if (finalCheck := (check if headCheck == 'True' else check + ' and ' + headCheck)) is not None else None))(__let_val_1[0], __let_val_1[1]) if isinstance(__let_val_1, tuple) and len(__let_val_1) == 2 else None
def __helper_16(__let_val_2):
    return (lambda headCheck, headBindings: __helper_15(generatePatternCheck(data.tail)(var + '[1:]')))(__let_val_2[0], __let_val_2[1]) if isinstance(__let_val_2, tuple) and len(__let_val_2) == 2 else None
def __helper_17(__match_val):
    return (((var + ' == ' + toString(__match_val._field0), []) if isinstance(__match_val, IntPattern) else None)) or (((var + ' == ' + toString(__match_val._field0), []) if isinstance(__match_val, FloatPattern) else None)) or (((var + ' == ' + reprString(__match_val._field0), []) if isinstance(__match_val, StringPattern) else None)) or (((var + ' == ' + reprChar(__match_val._field0), []) if isinstance(__match_val, CharPattern) else None)) or (((var + ' is ' + 'True' if __match_val._field0 else 'False', []) if isinstance(__match_val, BoolPattern) else None)) or ((('True', [(__match_val._field0, var)]) if isinstance(__match_val, VarPattern) else None)) or ((('True', []) if __match_val is WildcardPattern else None)) or (((var + ' == []', []) if List.isEmpty(__match_val._field0) else ('isinstance(' + var + ', list)', []) if isinstance(__match_val, ListPattern) else None)) or ((((__helper_16(generatePatternCheck(__match_val._field0.head)(var + '[0]'))) if (check := ('isinstance(' + var + ', list) and len(' + var + ') > 0')) is not None else None) if isinstance(__match_val, ConsPattern) else None)) or (((((((check, bindings)) if (bindings := (generateTuplePatternBindings(__match_val._field0)(var)(0)([]))) is not None else None)) if (check := ('isinstance(' + var + ', tuple) and len(' + var + ') == ' + toString(List.length(__match_val._field0)))) is not None else None) if isinstance(__match_val, TuplePattern) else None)) or (((var + ' is ' + __match_val._field0.name, []) if List.isEmpty(__match_val._field0.args) else (((((check, bindings)) if (bindings := (generateConstructorPatternBindings(__match_val._field0.args)(var)(0)([]))) is not None else None)) if (check := ('isinstance(' + var + ', ' + __match_val._field0.name + ')')) is not None else None) if isinstance(__match_val, ConstructorPattern) else None)) or (('True', []))
def __helper_18(__match_val):
    return ((result if __match_val == [] else None)) or ((((generateDoBindings(__match_val[1:])('(lambda ' + __match_val[0].name + ': ' + result + ')(' + valueCode + ')')) if (valueCode := (generateExpr(__match_val[0].value))) is not None else None) if isinstance(__match_val, list) and len(__match_val) > 0 else None))
def __helper_19(__let_val_3):
    return (lambda newBindings: generateTuplePatternBindings(rest)(var)(index + 1)(newBindings + bindings))(__let_val_3[1]) if isinstance(__let_val_3, tuple) and len(__let_val_3) == 2 else None
def __helper_20(__match_val):
    return ((List.reverse(bindings) if __match_val == [] else None)) or ((((__helper_19(generatePatternCheck(__match_val[0])(elemVar))) if (elemVar := (var + '[' + toString(index) + ']')) is not None else None) if isinstance(__match_val, list) and len(__match_val) > 0 else None))
def __helper_21(__let_val_4):
    return (lambda newBindings: generateConstructorPatternBindings(rest)(var)(index + 1)(newBindings + bindings))(__let_val_4[1]) if isinstance(__let_val_4, tuple) and len(__let_val_4) == 2 else None
def __helper_22(__match_val):
    return ((List.reverse(bindings) if __match_val == [] else None)) or ((((__helper_21(generatePatternCheck(__match_val[0])(argVar))) if (argVar := (var + '._field' + toString(index))) is not None else None) if isinstance(__match_val, list) and len(__match_val) > 0 else None))