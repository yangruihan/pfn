# ============================================================

# AUTO-GENERATED CODE - DO NOT EDIT

# Generated by Pfn compiler

# Generated at: 2026-02-28 21:52:37

# ============================================================



from __future__ import annotations

from stdlib import String, List, Dict, Set, Maybe, Result, Just, Nothing, Ok, Err, Record

from stdlib import reverse, _not_

from bootstrap.Token import *

from dataclasses import dataclass

@dataclass
class LexerError:
    message: str
    span: Span

from dataclasses import dataclass

@dataclass
class LexerState:
    source: str
    pos: int
    line: int
    column: int
    tokens: list[Token]

from dataclasses import dataclass
from typing import Union

@dataclass
class Ok:
    _field0: a

@dataclass
class Error:
    _field0: LexerError

LexerResult = Union[Ok, Error]

def initLexer(source):
    return Record({"source": source, "pos": 0, "line": 1, "column": 1, "tokens": []})

def atEnd(state):
    return state.pos >= String.length(state.source)

def peek(state):
    return '\x00' if atEnd(state) else String.unsafeAt(state.pos)(state.source)

def peekOffset(offset):
    return lambda state: (('\x00' if pos >= String.length(state.source) else String.unsafeAt(pos)(state.source)) if (pos := (state.pos + offset)) is not None else None)

def advance(state):
    return ('\x00', state) if atEnd(state) else (((((char, newState)) if (newState := (Record({**state, "pos": state.pos + 1, "line": state.line + 1, "column": 1}) if char == '\n' else Record({**state, "pos": state.pos + 1, "column": state.column + 1}))) is not None else None)) if (char := (String.unsafeAt(state.pos)(state.source))) is not None else None)

def _match_(expected):
    return lambda state: (False, state) if atEnd(state) or String.unsafeAt(state.pos)(state.source) != expected else __helper_0(advance(state))

def currentSpan(state):
    return makeSpan(state.pos)(state.pos)(state.line)(state.column)

def spanFrom(startPos):
    return lambda startLine: lambda startCol: lambda state: makeSpan(startPos)(state.pos)(startLine)(startCol)

def addToken(tt):
    return lambda value: lambda span: lambda state: ((Record({**state, "tokens": state.tokens + [newToken]})) if (newToken := (Record({"tokenType": tt, "value": value, "span": span}))) is not None else None)

def addSimpleToken(tt):
    return lambda span: lambda state: addToken(tt)(NoValue)(span)(state)

def addStringToken(tt):
    return lambda value: lambda span: lambda state: addToken(tt)(StringValue(value))(span)(state)

def isWhitespace(c):
    return c == ' ' or c == '\t' or c == '\n' or c == '\r'

def isDigit(c):
    return c >= '0' and c <= '9'

def isAlpha(c):
    return c >= 'a' and c <= 'z' or c >= 'A' and c <= 'Z'

def isAlnum(c):
    return isAlpha(c) or isDigit(c)

def skipLineComment(state):
    return state if atEnd(state) or peek(state) == '\n' else skipLineComment(snd(advance(state)))

def scanNumber(startPos):
    return lambda startLine: lambda startCol: lambda firstChar: lambda state: (lambda go: __helper_7(go([firstChar])(state)))(lambda digits: lambda st: __helper_1(advance(st)) if isDigit(peek(st)) or peek(st) == '_' else (digits, st))

def escapeChar(c):
    return __helper_8(c)

def scanString(startPos):
    return lambda startLine: lambda startCol: lambda state: (lambda go: __helper_13(go([])(state)))(lambda chars: lambda st: Error(Record({"message": 'Unterminated string', "span": spanFrom(startPos)(startLine)(startCol)(st)})) if atEnd(st) else __helper_9(advance(st)) if peek(st) == '"' else __helper_11(advance(st)) if peek(st) == '\\' else __helper_12(advance(st)))

def scanChar(startPos):
    return lambda startLine: lambda startCol: lambda state: Error(Record({"message": 'Unterminated character literal', "span": spanFrom(startPos)(startLine)(startCol)(state)})) if atEnd(state) else Error(Record({"message": 'Empty character literal', "span": spanFrom(startPos)(startLine)(startCol)(state)})) if peek(state) == "'" else __helper_17(__helper_15(advance(state)) if peek(state) == '\\' else advance(state))

def scanIdentifier(startPos):
    return lambda startLine: lambda startCol: lambda state: (lambda go: __helper_20(go([])(state)))(lambda chars: lambda st: __helper_18(advance(st)) if isAlnum(peek(st)) or peek(st) == '_' else (chars, st))

def scanToken(state):
    return ((((((__helper_21(advance(state))) if (startCol := (state.column)) is not None else None)) if (startLine := (state.line)) is not None else None)) if (startPos := (state.pos)) is not None else None)

def scanOperator(char):
    return lambda startPos: lambda startLine: lambda startCol: lambda state: (((lambda addTok: __helper_33(char))(lambda tt: Ok(addSimpleToken(tt)(span)(state)))) if (span := (spanFrom(startPos)(startLine)(startCol)(state))) is not None else None)

def tokenizeLoop(state):
    return (lambda go: go(state))(lambda st: Ok(st) if atEnd(st) else __helper_34(scanToken(st)))

def tokenize(source):
    return ((__helper_35(tokenizeLoop(state))) if (state := (initLexer(source))) is not None else None)

def tokenizeOrThrow(source):
    return __helper_36(tokenize(source))


# Helper functions to avoid deep nesting
def __helper_0(__let_val_0):
    return (lambda newState: (True, newState))(__let_val_0[1]) if isinstance(__let_val_0, tuple) and len(__let_val_0) == 2 else None
def __helper_1(__let_val_1):
    return (lambda c, st2: go(digits)(st2) if c == '_' else go([c] + digits)(st2))(__let_val_1[0], __let_val_1[1]) if isinstance(__let_val_1, tuple) and len(__let_val_1) == 2 else None
def __helper_2(__let_val_2):
    return (lambda digits4, state6: ((((((addToken(FLOAT)(FloatValue(value))(span)(state6)) if (span := (spanFrom(startPos)(startLine)(startCol)(state6))) is not None else None)) if (value := (String.toFloat(str))) is not None else None)) if (str := (String.fromList(reverse(digits4)))) is not None else None))(__let_val_2[0], __let_val_2[1]) if isinstance(__let_val_2, tuple) and len(__let_val_2) == 2 else None
def __helper_3(__let_val_3):
    return (lambda sign, state5: ((__helper_2(go(digits3)(state5))) if (digits3 := ([e] + digits2 if sign == '\x00' else [sign] + [e] + digits2)) is not None else None))(__let_val_3[0], __let_val_3[1]) if isinstance(__let_val_3, tuple) and len(__let_val_3) == 2 else None
def __helper_4(__let_val_4):
    return (lambda e, state4: __helper_3(advance(state4) if peek(state4) == '+' or peek(state4) == '-' else ('\x00', state4)))(__let_val_4[0], __let_val_4[1]) if isinstance(__let_val_4, tuple) and len(__let_val_4) == 2 else None
def __helper_5(__let_val_5):
    return (lambda digits2, state3: __helper_4(advance(state3)) if peek(state3) == 'e' or peek(state3) == 'E' else ((((((addToken(FLOAT)(FloatValue(value))(span)(state1)) if (span := (spanFrom(startPos)(startLine)(startCol)(state1))) is not None else None)) if (value := (String.toFloat(str))) is not None else None)) if (str := (String.fromList(reverse(digits2)))) is not None else None))(__let_val_5[0], __let_val_5[1]) if isinstance(__let_val_5, tuple) and len(__let_val_5) == 2 else None
def __helper_6(__let_val_6):
    return (lambda dot, state2: __helper_5(go([dot] + digits1)(state2)))(__let_val_6[0], __let_val_6[1]) if isinstance(__let_val_6, tuple) and len(__let_val_6) == 2 else None
def __helper_7(__let_val_7):
    return (lambda digits1, state1: __helper_6(advance(state1)) if peek(state1) == '.' and isDigit(peekOffset(1)(state1)) else ((((((addToken(INT)(IntValue(value))(span)(state1)) if (span := (spanFrom(startPos)(startLine)(startCol)(state1))) is not None else None)) if (value := (String.toInt(str))) is not None else None)) if (str := (String.fromList(reverse(digits1)))) is not None else None))(__let_val_7[0], __let_val_7[1]) if isinstance(__let_val_7, tuple) and len(__let_val_7) == 2 else None
def __helper_8(__match_val):
    return (('\n' if __match_val == 'n' else None)) or (('\t' if __match_val == 't' else None)) or (('\r' if __match_val == 'r' else None)) or (('\\' if __match_val == '\\' else None)) or (('"' if __match_val == '"' else None)) or (("'" if __match_val == "'" else None)) or (c)
def __helper_9(__let_val_8):
    return (lambda st2: Ok(chars)(st2))(__let_val_8[1]) if isinstance(__let_val_8, tuple) and len(__let_val_8) == 2 else None
def __helper_10(__let_val_9):
    return (lambda c, st3: go([escapeChar(c)] + chars)(st3))(__let_val_9[0], __let_val_9[1]) if isinstance(__let_val_9, tuple) and len(__let_val_9) == 2 else None
def __helper_11(__let_val_10):
    return (lambda st2: Error(Record({"message": 'Unterminated escape sequence', "span": spanFrom(startPos)(startLine)(startCol)(st2)})) if atEnd(st2) else __helper_10(advance(st2)))(__let_val_10[1]) if isinstance(__let_val_10, tuple) and len(__let_val_10) == 2 else None
def __helper_12(__let_val_11):
    return (lambda c, st2: go([c] + chars)(st2))(__let_val_11[0], __let_val_11[1]) if isinstance(__let_val_11, tuple) and len(__let_val_11) == 2 else None
def __helper_13(__match_val):
    return ((((((Ok(addToken(STRING)(StringValue(str))(span)(__match_val._field1))) if (span := (spanFrom(startPos)(startLine)(startCol)(__match_val._field1))) is not None else None)) if (str := (String.fromList(reverse(__match_val._field0)))) is not None else None) if isinstance(__match_val, Ok) else None)) or ((Error(__match_val._field0) if isinstance(__match_val, Error) else None))
def __helper_14(__let_val_12):
    return (lambda c, s2: (escapeChar(c), s2))(__let_val_12[0], __let_val_12[1]) if isinstance(__let_val_12, tuple) and len(__let_val_12) == 2 else None
def __helper_15(__let_val_13):
    return (lambda s1: ('\x00', s1) if atEnd(s1) else __helper_14(advance(s1)))(__let_val_13[1]) if isinstance(__let_val_13, tuple) and len(__let_val_13) == 2 else None
def __helper_16(__let_val_14):
    return (lambda state3: ((Ok(addToken(CHAR)(CharValue(charValue))(span)(state3))) if (span := (spanFrom(startPos)(startLine)(startCol)(state3))) is not None else None))(__let_val_14[1]) if isinstance(__let_val_14, tuple) and len(__let_val_14) == 2 else None
def __helper_17(__let_val_15):
    return (lambda charValue, state2: Error(Record({"message": 'Unterminated character literal', "span": spanFrom(startPos)(startLine)(startCol)(state2)})) if atEnd(state2) or peek(state2) != "'" else __helper_16(advance(state2)))(__let_val_15[0], __let_val_15[1]) if isinstance(__let_val_15, tuple) and len(__let_val_15) == 2 else None
def __helper_18(__let_val_16):
    return (lambda c, st2: go([c] + chars)(st2))(__let_val_16[0], __let_val_16[1]) if isinstance(__let_val_16, tuple) and len(__let_val_16) == 2 else None
def __helper_19(__match_val):
    return ((addStringToken(__match_val._field0)(text)(span)(state2) if isinstance(__match_val, Just) else None)) or ((addStringToken(IDENT)(text)(span)(state2) if __match_val is Nothing else None))
def __helper_20(__let_val_17):
    return (lambda chars, state2: ((((__helper_19(lookupKeyword(text))) if (span := (spanFrom(startPos)(startLine)(startCol)(state2))) is not None else None)) if (text := (String.fromList(reverse(chars)))) is not None else None))(__let_val_17[0], __let_val_17[1]) if isinstance(__let_val_17, tuple) and len(__let_val_17) == 2 else None
def __helper_21(__let_val_18):
    return (lambda char, state1: Ok(state1) if isWhitespace(char) else Ok(skipLineComment(state1)) if char == '-' and peek(state1) == '-' else Ok(scanNumber(startPos)(startLine)(startCol)(char)(state1)) if isDigit(char) else scanString(startPos)(startLine)(startCol)(state1) if char == '"' else scanChar(startPos)(startLine)(startCol)(state1) if char == "'" else Ok(addSimpleToken(UNDERSCORE)(spanFrom(startPos)(startLine)(startCol)(state1))(state1)) if char == '_' and _not_(isAlnum(peek(state1)) or peek(state1) == '_') else Ok(scanIdentifier(startPos)(startLine)(startCol)(state)) if isAlpha(char) or char == '_' else scanOperator(char)(startPos)(startLine)(startCol)(state1))(__let_val_18[0], __let_val_18[1]) if isinstance(__let_val_18, tuple) and len(__let_val_18) == 2 else None
def __helper_22(__let_val_19):
    return (lambda matched, state2: Ok(addSimpleToken(DOUBLE_PLUS)(span)(state2)) if matched else addTok(PLUS))(__let_val_19[0], __let_val_19[1]) if isinstance(__let_val_19, tuple) and len(__let_val_19) == 2 else None
def __helper_23(__let_val_20):
    return (lambda matched, state2: Ok(addSimpleToken(ARROW)(span)(state2)) if matched else addTok(MINUS))(__let_val_20[0], __let_val_20[1]) if isinstance(__let_val_20, tuple) and len(__let_val_20) == 2 else None
def __helper_24(__let_val_21):
    return (lambda matched, state2: Ok(addSimpleToken(DOUBLE_COLON)(span)(state2)) if matched else addTok(COLON))(__let_val_21[0], __let_val_21[1]) if isinstance(__let_val_21, tuple) and len(__let_val_21) == 2 else None
def __helper_25(__let_val_22):
    return (lambda matched2, state3: Ok(addSimpleToken(EQ)(span)(state3)) if matched2 else addTok(EQUALS))(__let_val_22[0], __let_val_22[1]) if isinstance(__let_val_22, tuple) and len(__let_val_22) == 2 else None
def __helper_26(__let_val_23):
    return (lambda matched1, state2: Ok(addSimpleToken(FAT_ARROW)(span)(state2)) if matched1 else __helper_25(_match_('=')(state)))(__let_val_23[0], __let_val_23[1]) if isinstance(__let_val_23, tuple) and len(__let_val_23) == 2 else None
def __helper_27(__let_val_24):
    return (lambda matched, state2: Ok(addSimpleToken(NEQ)(span)(state2)) if matched else addTok(BANG))(__let_val_24[0], __let_val_24[1]) if isinstance(__let_val_24, tuple) and len(__let_val_24) == 2 else None
def __helper_28(__let_val_25):
    return (lambda matched2, state3: Ok(addSimpleToken(LEFT_ARROW)(span)(state3)) if matched2 else addTok(LT))(__let_val_25[0], __let_val_25[1]) if isinstance(__let_val_25, tuple) and len(__let_val_25) == 2 else None
def __helper_29(__let_val_26):
    return (lambda matched1, state2: Ok(addSimpleToken(LE)(span)(state2)) if matched1 else __helper_28(_match_('-')(state2)))(__let_val_26[0], __let_val_26[1]) if isinstance(__let_val_26, tuple) and len(__let_val_26) == 2 else None
def __helper_30(__let_val_27):
    return (lambda matched, state2: Ok(addSimpleToken(GE)(span)(state2)) if matched else addTok(GT))(__let_val_27[0], __let_val_27[1]) if isinstance(__let_val_27, tuple) and len(__let_val_27) == 2 else None
def __helper_31(__let_val_28):
    return (lambda matched, state2: Ok(addSimpleToken(DOUBLE_PIPE)(span)(state2)) if matched else addTok(PIPE))(__let_val_28[0], __let_val_28[1]) if isinstance(__let_val_28, tuple) and len(__let_val_28) == 2 else None
def __helper_32(__let_val_29):
    return (lambda matched, state2: Ok(addSimpleToken(DOUBLE_AMP)(span)(state2)) if matched else addTok(AMP))(__let_val_29[0], __let_val_29[1]) if isinstance(__let_val_29, tuple) and len(__let_val_29) == 2 else None
def __helper_33(__match_val):
    return ((__helper_22(_match_('+')(state)) if __match_val == '+' else None)) or ((__helper_23(_match_('>')(state)) if __match_val == '-' else None)) or ((addTok(STAR) if __match_val == '*' else None)) or ((addTok(SLASH) if __match_val == '/' else None)) or ((addTok(PERCENT) if __match_val == '%' else None)) or ((__helper_24(_match_(':')(state)) if __match_val == ':' else None)) or ((__helper_26(_match_('>')(state)) if __match_val == '=' else None)) or ((__helper_27(_match_('=')(state)) if __match_val == '!' else None)) or ((addTok(AT) if __match_val == '@' else None)) or ((__helper_29(_match_('=')(state)) if __match_val == '<' else None)) or ((__helper_30(_match_('=')(state)) if __match_val == '>' else None)) or ((__helper_31(_match_('|')(state)) if __match_val == '|' else None)) or ((__helper_32(_match_('&')(state)) if __match_val == '&' else None)) or ((addTok(LPAREN) if __match_val == '(' else None)) or ((addTok(RPAREN) if __match_val == ')' else None)) or ((addTok(LBRACKET) if __match_val == '[' else None)) or ((addTok(RBRACKET) if __match_val == ']' else None)) or ((addTok(LBRACE) if __match_val == '{' else None)) or ((addTok(RBRACE) if __match_val == '}' else None)) or ((addTok(COMMA) if __match_val == ',' else None)) or ((addTok(DOT) if __match_val == '.' else None)) or ((addTok(SEMICOLON) if __match_val == ';' else None)) or ((addTok(BACKTICK) if __match_val == '`' else None)) or (Error(Record({"message": 'Unexpected character: ' + String.fromChar(char), "span": span})))
def __helper_34(__match_val):
    return ((go(__match_val._field0) if isinstance(__match_val, Ok) else None)) or ((Error(__match_val._field0) if isinstance(__match_val, Error) else None))
def __helper_35(__match_val):
    return ((((((Ok(__match_val._field0.tokens + [eofToken])) if (eofToken := (Record({"tokenType": EOF, "value": NoValue, "span": eofSpan}))) is not None else None)) if (eofSpan := (currentSpan(__match_val._field0))) is not None else None) if isinstance(__match_val, Ok) else None)) or ((Error(__match_val._field0) if isinstance(__match_val, Error) else None))
def __helper_36(__match_val):
    return ((__match_val._field0 if isinstance(__match_val, Ok) else None)) or ((error('Lexer error: ' + __match_val._field0.message + ' at ' + show(__match_val._field0.span)) if isinstance(__match_val, Error) else None))