# ============================================================

# AUTO-GENERATED CODE - DO NOT EDIT

# Generated by Pfn compiler

# Generated at: 2026-02-28 21:52:37

# ============================================================



from __future__ import annotations

from stdlib import String, List, Dict, Set, Maybe, Result, Just, Nothing, Ok, Err, Record

from stdlib import reverse, _not_

from dataclasses import dataclass
from typing import Union

class INT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class FLOAT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class STRING:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class CHAR:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class IDENT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_DEF:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_LET:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_IN:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_IF:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_THEN:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_ELSE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_MATCH:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_WITH:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_TYPE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_INTERFACE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_IMPL:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_IMPORT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_EXPORT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_MODULE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_AS:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_EFFECT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_HANDLER:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_HANDLE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_DO:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_FORALL:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_EXISTS:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_DATA:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_FAMILY:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_WHERE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_FN:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class KW_GADT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class TRUE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class FALSE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class PLUS:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class MINUS:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class STAR:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class SLASH:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class PERCENT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class ARROW:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class FAT_ARROW:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class DOUBLE_COLON:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class EQUALS:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class EQ:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class NEQ:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class LT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class LE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class GT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class GE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class PIPE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class DOUBLE_PIPE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class AMP:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class DOUBLE_AMP:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class LEFT_ARROW:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class DOUBLE_PLUS:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class BANG:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class AT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class LPAREN:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class RPAREN:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class LBRACKET:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class RBRACKET:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class LBRACE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class RBRACE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class COMMA:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class COLON:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class DOT:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class UNDERSCORE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class SEMICOLON:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class BACKTICK:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class NEWLINE:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

class EOF:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

TokenType = Union[INT, FLOAT, STRING, CHAR, IDENT, KW_DEF, KW_LET, KW_IN, KW_IF, KW_THEN, KW_ELSE, KW_MATCH, KW_WITH, KW_TYPE, KW_INTERFACE, KW_IMPL, KW_IMPORT, KW_EXPORT, KW_MODULE, KW_AS, KW_EFFECT, KW_HANDLER, KW_HANDLE, KW_DO, KW_FORALL, KW_EXISTS, KW_DATA, KW_FAMILY, KW_WHERE, KW_FN, KW_GADT, TRUE, FALSE, PLUS, MINUS, STAR, SLASH, PERCENT, ARROW, FAT_ARROW, DOUBLE_COLON, EQUALS, EQ, NEQ, LT, LE, GT, GE, PIPE, DOUBLE_PIPE, AMP, DOUBLE_AMP, LEFT_ARROW, DOUBLE_PLUS, BANG, AT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, COMMA, COLON, DOT, UNDERSCORE, SEMICOLON, BACKTICK, NEWLINE, EOF]
INT = INT()
FLOAT = FLOAT()
STRING = STRING()
CHAR = CHAR()
IDENT = IDENT()
KW_DEF = KW_DEF()
KW_LET = KW_LET()
KW_IN = KW_IN()
KW_IF = KW_IF()
KW_THEN = KW_THEN()
KW_ELSE = KW_ELSE()
KW_MATCH = KW_MATCH()
KW_WITH = KW_WITH()
KW_TYPE = KW_TYPE()
KW_INTERFACE = KW_INTERFACE()
KW_IMPL = KW_IMPL()
KW_IMPORT = KW_IMPORT()
KW_EXPORT = KW_EXPORT()
KW_MODULE = KW_MODULE()
KW_AS = KW_AS()
KW_EFFECT = KW_EFFECT()
KW_HANDLER = KW_HANDLER()
KW_HANDLE = KW_HANDLE()
KW_DO = KW_DO()
KW_FORALL = KW_FORALL()
KW_EXISTS = KW_EXISTS()
KW_DATA = KW_DATA()
KW_FAMILY = KW_FAMILY()
KW_WHERE = KW_WHERE()
KW_FN = KW_FN()
KW_GADT = KW_GADT()
TRUE = TRUE()
FALSE = FALSE()
PLUS = PLUS()
MINUS = MINUS()
STAR = STAR()
SLASH = SLASH()
PERCENT = PERCENT()
ARROW = ARROW()
FAT_ARROW = FAT_ARROW()
DOUBLE_COLON = DOUBLE_COLON()
EQUALS = EQUALS()
EQ = EQ()
NEQ = NEQ()
LT = LT()
LE = LE()
GT = GT()
GE = GE()
PIPE = PIPE()
DOUBLE_PIPE = DOUBLE_PIPE()
AMP = AMP()
DOUBLE_AMP = DOUBLE_AMP()
LEFT_ARROW = LEFT_ARROW()
DOUBLE_PLUS = DOUBLE_PLUS()
BANG = BANG()
AT = AT()
LPAREN = LPAREN()
RPAREN = RPAREN()
LBRACKET = LBRACKET()
RBRACKET = RBRACKET()
LBRACE = LBRACE()
RBRACE = RBRACE()
COMMA = COMMA()
COLON = COLON()
DOT = DOT()
UNDERSCORE = UNDERSCORE()
SEMICOLON = SEMICOLON()
BACKTICK = BACKTICK()
NEWLINE = NEWLINE()
EOF = EOF()

from dataclasses import dataclass

@dataclass
class Span:
    start: int
    end: int
    line: int
    column: int

from dataclasses import dataclass

@dataclass
class Token:
    tokenType: TokenType
    value: TokenValue
    span: Span

from dataclasses import dataclass
from typing import Union

@dataclass
class IntValue:
    _field0: int

@dataclass
class FloatValue:
    _field0: float

@dataclass
class StringValue:
    _field0: str

@dataclass
class CharValue:
    _field0: Char

class NoValue:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

TokenValue = Union[IntValue, FloatValue, StringValue, CharValue, NoValue]
NoValue = NoValue()

keywords = Dict.fromList([('def', KW_DEF), ('let', KW_LET), ('in', KW_IN), ('if', KW_IF), ('then', KW_THEN), ('else', KW_ELSE), ('match', KW_MATCH), ('with', KW_WITH), ('type', KW_TYPE), ('gadt', KW_GADT), ('interface', KW_INTERFACE), ('impl', KW_IMPL), ('import', KW_IMPORT), ('export', KW_EXPORT), ('module', KW_MODULE), ('as', KW_AS), ('effect', KW_EFFECT), ('handler', KW_HANDLER), ('handle', KW_HANDLE), ('do', KW_DO), ('forall', KW_FORALL), ('exists', KW_EXISTS), ('data', KW_DATA), ('family', KW_FAMILY), ('where', KW_WHERE), ('fn', KW_FN), ('True', TRUE), ('False', FALSE)])

def lookupKeyword(name):
    return Dict.lookup(name)(keywords)

def makeSpan(start):
    return lambda end: lambda line: lambda column: Record({"start": start, "end": end, "line": line, "column": column})

def token(tt):
    return lambda span: Record({"tokenType": tt, "value": NoValue, "span": span})

def stringToken(tt):
    return lambda value: lambda span: Record({"tokenType": tt, "value": StringValue(value), "span": span})

def intToken(value):
    return lambda span: Record({"tokenType": INT, "value": IntValue(value), "span": span})

def floatToken(value):
    return lambda span: Record({"tokenType": FLOAT, "value": FloatValue(value), "span": span})

def charToken(value):
    return lambda span: Record({"tokenType": CHAR, "value": CharValue(value), "span": span})

def tokenTypeName(tt):
    return __helper_0(tt)


# Helper functions to avoid deep nesting
def __helper_0(__match_val):
    return (('INT' if __match_val is INT else None)) or (('FLOAT' if __match_val is FLOAT else None)) or (('STRING' if __match_val is STRING else None)) or (('CHAR' if __match_val is CHAR else None)) or (('IDENT' if __match_val is IDENT else None)) or (('KW_DEF' if __match_val is KW_DEF else None)) or (('KW_LET' if __match_val is KW_LET else None)) or (('KW_IN' if __match_val is KW_IN else None)) or (('KW_IF' if __match_val is KW_IF else None)) or (('KW_THEN' if __match_val is KW_THEN else None)) or (('KW_ELSE' if __match_val is KW_ELSE else None)) or (('KW_MATCH' if __match_val is KW_MATCH else None)) or (('KW_WITH' if __match_val is KW_WITH else None)) or (('KW_TYPE' if __match_val is KW_TYPE else None)) or (('KW_INTERFACE' if __match_val is KW_INTERFACE else None)) or (('KW_IMPL' if __match_val is KW_IMPL else None)) or (('KW_IMPORT' if __match_val is KW_IMPORT else None)) or (('KW_EXPORT' if __match_val is KW_EXPORT else None)) or (('KW_MODULE' if __match_val is KW_MODULE else None)) or (('KW_AS' if __match_val is KW_AS else None)) or (('KW_EFFECT' if __match_val is KW_EFFECT else None)) or (('KW_HANDLER' if __match_val is KW_HANDLER else None)) or (('KW_HANDLE' if __match_val is KW_HANDLE else None)) or (('KW_DO' if __match_val is KW_DO else None)) or (('KW_FORALL' if __match_val is KW_FORALL else None)) or (('KW_EXISTS' if __match_val is KW_EXISTS else None)) or (('KW_DATA' if __match_val is KW_DATA else None)) or (('KW_FAMILY' if __match_val is KW_FAMILY else None)) or (('KW_WHERE' if __match_val is KW_WHERE else None)) or (('KW_FN' if __match_val is KW_FN else None)) or (('KW_GADT' if __match_val is KW_GADT else None)) or (('TRUE' if __match_val is TRUE else None)) or (('FALSE' if __match_val is FALSE else None)) or (('PLUS' if __match_val is PLUS else None)) or (('MINUS' if __match_val is MINUS else None)) or (('STAR' if __match_val is STAR else None)) or (('SLASH' if __match_val is SLASH else None)) or (('PERCENT' if __match_val is PERCENT else None)) or (('ARROW' if __match_val is ARROW else None)) or (('FAT_ARROW' if __match_val is FAT_ARROW else None)) or (('DOUBLE_COLON' if __match_val is DOUBLE_COLON else None)) or (('EQUALS' if __match_val is EQUALS else None)) or (('EQ' if __match_val is EQ else None)) or (('NEQ' if __match_val is NEQ else None)) or (('LT' if __match_val is LT else None)) or (('LE' if __match_val is LE else None)) or (('GT' if __match_val is GT else None)) or (('GE' if __match_val is GE else None)) or (('PIPE' if __match_val is PIPE else None)) or (('DOUBLE_PIPE' if __match_val is DOUBLE_PIPE else None)) or (('AMP' if __match_val is AMP else None)) or (('DOUBLE_AMP' if __match_val is DOUBLE_AMP else None)) or (('LEFT_ARROW' if __match_val is LEFT_ARROW else None)) or (('DOUBLE_PLUS' if __match_val is DOUBLE_PLUS else None)) or (('BANG' if __match_val is BANG else None)) or (('AT' if __match_val is AT else None)) or (('LPAREN' if __match_val is LPAREN else None)) or (('RPAREN' if __match_val is RPAREN else None)) or (('LBRACKET' if __match_val is LBRACKET else None)) or (('RBRACKET' if __match_val is RBRACKET else None)) or (('LBRACE' if __match_val is LBRACE else None)) or (('RBRACE' if __match_val is RBRACE else None)) or (('COMMA' if __match_val is COMMA else None)) or (('COLON' if __match_val is COLON else None)) or (('DOT' if __match_val is DOT else None)) or (('UNDERSCORE' if __match_val is UNDERSCORE else None)) or (('SEMICOLON' if __match_val is SEMICOLON else None)) or (('BACKTICK' if __match_val is BACKTICK else None)) or (('NEWLINE' if __match_val is NEWLINE else None)) or (('EOF' if __match_val is EOF else None))